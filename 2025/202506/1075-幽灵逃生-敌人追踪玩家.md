# 1075-幽灵逃生-敌人追踪玩家

## 目标

显示敌人幽灵，并且可以跟踪玩家，持续向玩家移动。

## 环境

- Time 2026-01-09
- Zig 0.15.1

## 参考

1. <https://www.bilibili.com/video/BV1jf9XYQEhW>

## 想法

仿照玩家模块，新增一个敌人模块，实现起来不复杂。

## scene.zig

场景中加入了敌人模块的初始化，更新和渲染。

```zig
const std = @import("std");
const zhu = @import("zhu");

const window = zhu.window;
const batch = zhu.batch;
const camera = zhu.camera;

const player = @import("player.zig");
const enemy = @import("enemy.zig");

var isHelp = false;
var isDebug = false;
var vertexBuffer: []batch.Vertex = undefined;

const atlas: zhu.Atlas = @import("zon/atlas.zon");

pub var worldSize: zhu.Vector2 = undefined; // 世界大小

pub fn init() void {
    window.initText(@import("zon/font.zon"), 24);

    vertexBuffer = window.alloc(batch.Vertex, 5000);
    zhu.graphics.frameStats(true);
    batch.init(window.logicSize, vertexBuffer);
    batch.whiteImage = zhu.graphics.imageId("white.png");

    zhu.assets.loadAtlas(atlas);
    worldSize = window.logicSize.scale(3); // 设置世界大小

    player.init(worldSize.scale(0.5)); // 将玩家移动到世界中心
    enemy.init();
}

pub fn update(delta: f32) void {
    if (window.isKeyRelease(.H)) isHelp = !isHelp;
    if (window.isKeyRelease(.X)) isDebug = !isDebug;

    if (window.isKeyDown(.LEFT_ALT) and window.isKeyRelease(.ENTER)) {
        return window.toggleFullScreen();
    }

    const speed: f32 = std.math.round(400 * delta);
    if (window.isKeyDown(.UP)) camera.position.y -= speed;
    if (window.isKeyDown(.DOWN)) camera.position.y += speed;
    if (window.isKeyDown(.LEFT)) camera.position.x -= speed;
    if (window.isKeyDown(.RIGHT)) camera.position.x += speed;

    player.update(delta, worldSize);
    cameraFollow(player.position);
    enemy.update(delta);
}

pub fn draw() void {
    camera.beginDraw(.{});
    defer camera.endDraw();
    window.keepAspectRatio();

    // const gridColor = zhu.graphics.rgb(0.5, 0.5, 0.5);
    // const area = zhu.Rect.init(.zero, worldSize);
    // drawGrid(area, 80, gridColor);
    // camera.drawRectBorder(area, 10, .white);

    enemy.draw(); // 敌人绘制
    player.draw(); // 玩家绘制

    camera.mode = .local;
    defer camera.mode = .world;

    if (isHelp) drawHelpInfo() else if (isDebug) drawDebugInfo();
}

fn drawGrid(area: zhu.Rect, width: f32, lineColor: zhu.Color) void {
    const max = area.max();
    const color = camera.LineOption{ .color = lineColor };

    var min = area.min;
    while (min.x < max.x) : (min.x += width) {
        camera.drawAxisLine(min, .init(min.x, max.y), color);
    }

    min = area.min;
    while (min.y < max.y) : (min.y += width) {
        camera.drawAxisLine(min, .init(max.x, min.y), color);
    }
}

fn cameraFollow(pos: zhu.Vector2) void {
    // const scaleSize = window.logicSize.div(camera.scale);
    // const half = scaleSize.scale(0.5);
    const max = worldSize.sub(window.logicSize).max(.zero);
    const halfWindowSize = window.logicSize.scale(0.5);
    const square: zhu.Vector2 = .square(30);
    camera.position = pos.sub(halfWindowSize);
    camera.position.clamp(square.scale(-1), max.add(square));
}

fn drawHelpInfo() void {
    const text =
        \\按键说明：
        \\上：W，下：S，左：A，右：D
        \\确定：F，取消：Q，菜单：E
        \\帮助：H  按一次打开，再按一次关闭
    ;
    debutTextCount = zhu.text.computeTextCount(text);
    zhu.text.drawColor(text, .init(10, 10), .green);
}

var debutTextCount: u32 = 0;
fn drawDebugInfo() void {
    var buffer: [1024]u8 = undefined;
    const format =
        \\后端：{s}
        \\帧率：{}
        \\平滑：{d:.2}
        \\帧时：{d:.2}
        \\用时：{d:.2}
        \\显存：{}
        \\常量：{}
        \\绘制：{}
        \\图片：{}
        \\文字：{}
        \\内存：{}
        \\鼠标：{d:.2}，{d:.2}
        \\相机：{d:.2}，{d:.2}
    ;

    const stats = zhu.graphics.queryFrameStats();
    const text = zhu.format(&buffer, format, .{
        @tagName(zhu.graphics.queryBackend()),
        window.frameRate,
        window.currentSmoothTime * 1000,
        window.frameDeltaPerSecond,
        window.usedDeltaPerSecond,
        stats.size_append_buffer + stats.size_update_buffer,
        stats.size_apply_uniforms,
        stats.num_draw,
        camera.imageDrawCount(),
        // Debug 信息本身的次数也应该统计进去
        zhu.graphics.textCount + debutTextCount,
        window.countingAllocator.used,
        window.mousePosition.x,
        window.mousePosition.y,
        camera.position.x,
        camera.position.y,
    });

    debutTextCount = zhu.text.computeTextCount(text);
    zhu.text.drawColor(text, .init(10, 10), .green);
}

pub fn deinit() void {
    window.free(vertexBuffer);
}
```

## enemy.zig

```zig
const std = @import("std");
const zhu = @import("zhu");

const camera = zhu.camera;

const player = @import("player.zig");

pub const Enemy = struct {
    position: zhu.Vector2,
    animation: zhu.graphics.FrameAnimation,
};
const frames = zhu.graphics.framesX(4, .init(32, 32), 0.2);
const size = frames[0].area.size.scale(2);
const maxSpeed = 100;

var enemy: Enemy = undefined;

pub fn init() void {
    const image = zhu.graphics.getImage("sprite/ghost-Sheet.png");
    enemy = Enemy{
        .position = player.position.add(.init(200, 200)),
        .animation = .init(image, &frames),
    };
}

pub fn update(delta: f32) void {
    const dir = player.position.sub(enemy.position);
    const distance = dir.normalize().scale(maxSpeed * delta);
    enemy.position = enemy.position.add(distance);

    enemy.animation.update(delta);
}

pub fn draw() void {
    const image = enemy.animation.currentImage();
    camera.drawImage(image, enemy.position, .{
        .size = size,
    });
}
```

## 效果

![敌人追踪玩家][1]

[1]: images/幽灵逃生08.gif

## 附录
