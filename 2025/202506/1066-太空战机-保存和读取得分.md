# 1066-太空战机-保存和读取得分

## 目标

将得分榜的记录保存到文件中，下次启动时，再次加载出来。

## 环境

- Time 2025-12-10
- Zig 0.15.1

## 参考

1. <https://www.bilibili.com/video/BV1wSCFYQEyc>

## 想法

在之前游戏实现的保存和加载逻辑上进行修改的。

## end.zig

```zig
const std = @import("std");
const zhu = @import("zhu");

const camera = zhu.camera;
const text = zhu.text;
const window = zhu.window;

const player = @import("player.zig");
const scene = @import("scene.zig");

var nameUnicode: [20]u21 = undefined;
var nameIndex: u8 = 0;
var nameBuffer: [nameUnicode.len * 3]u8 = undefined;
var name: []u8 = &.{};

var blink: bool = true; // 输入光标闪烁
var blinkTimer: window.Timer = .init(0.7); // 输入光标闪烁
const Score = struct { name: []const u8, score: u32 = 0 };
var scoreBoard: [8]Score = undefined; // 最多显示 8 个
var scoreCount: u8 = 0; //没有任何得分记录

pub fn init() void {
    loadScore() catch |e| std.log.info("e: {}", .{e});
}

pub fn restart() void {
    nameIndex = 0;
}

pub fn handleEvent(event: *const zhu.window.Event) void {
    if (!scene.isTyping or event.type != .CHAR) return;
    if (nameIndex >= nameUnicode.len - 1) return; // 存不下了

    // 临时保存输入的用户名
    nameUnicode[nameIndex] = @intCast(event.char_code);
    nameIndex += 1;
    name = text.encodeUtf8(&nameBuffer, nameUnicode[0..nameIndex]);
}

pub fn update(delta: f32) void {
    // 输入光标闪烁计时器
    if (blinkTimer.isFinishedAfterUpdate(delta)) {
        blink = !blink;
        blinkTimer.elapsed = 0;
    }

    if (scene.isTyping) return updateTyping();

    if (window.isKeyPress(.J)) scene.restart();
}

fn updateTyping() void {
    if (nameIndex == 0) return; // 没有输入任何字符的时候，不处理。

    if (window.isKeyPress(.BACKSPACE)) {
        // 按退格的时候，删除一个字符，并且更新名字。
        nameIndex -= 1;
        name = text.encodeUtf8(&nameBuffer, nameUnicode[0..nameIndex]);
    }

    if (window.isKeyPress(.ENTER)) { // 确定输入
        scene.isTyping = false;
        updateScore(player.score);
    }
}

fn updateScore(score: u32) void {
    // 在得分记录满的情况下，只有大于最小的得分，才进行保存。
    if (scoreCount == scoreBoard.len and
        player.score <= scoreBoard[scoreCount - 1].score) return;

    // 插入得分记录后，保存到文件中
    defer saveScore() catch @panic("save score failed");

    // 待插入的分数
    const scoreName = window.dupe(u8, name);
    const toInsert: Score = .{ .name = scoreName, .score = score };

    for (scoreBoard[0..scoreCount], 0..) |boardScore, i| {
        if (boardScore.score < score) {
            if (scoreCount == scoreBoard.len) {
                // 得分记录满了，释放删除的姓名的内存
                window.free(scoreBoard[scoreCount - 1].name);
            } else scoreCount += 1; // 没有满，增加一个记录
            const dest = scoreBoard[i + 1 .. scoreBoard.len];
            @memmove(dest, scoreBoard[i .. scoreBoard.len - 1]);
            scoreBoard[i] = toInsert;
            return;
        }
    }

    scoreBoard[scoreCount] = toInsert; // 插入到最后一个
    scoreCount += 1;
}

pub fn draw() void {
    if (scene.isTyping) return drawTyping();

    window.drawCenter("得分榜", 0.1, .{ .size = 72, .spacing = 5 });

    var y = 0.25 * window.logicSize.y;
    for (scoreBoard[0..scoreCount], 0..) |score, i| {
        text.drawFmt("{}. {s}", .init(100, y), .{ i + 1, score.name });
        const numberText = text.globalFormatNumber(score.score);
        text.drawRight(numberText, .init(window.logicSize.x - 100, y), .{});
        y += 50;
    }
    if (blink) {
        window.drawCenter("按J键重新开始游戏", 0.8, .{ .spacing = 5 });
    }
}

fn drawTyping() void {
    var buffer: [255]u8 = undefined;
    const score = zhu.format(&buffer, "你的得分是：{}", .{player.score});
    window.drawCenter(score, 0.1, .{ .spacing = 2 });

    window.drawCenter("GAME OVER", 0.35, .{ .size = 72, .spacing = 5 });

    const typing = "请输入你的名字，按回车键确认：";
    window.drawCenter(typing, 0.6, .{ .spacing = 2 });

    if (nameIndex == 0) {
        if (blink) window.drawCenter("_", 0.8, .{ .spacing = 2 });
    } else {
        const width = text.computeTextWidthOption(name, .{ .spacing = 2 });
        const x = (window.logicSize.x - width) / 2;
        const pos: zhu.math.Vector = .init(x, window.logicSize.y * 0.8);
        text.drawOption(name, pos, .{ .spacing = 2 });
        if (blink) text.draw("_", pos.addX(width + 4));
    }
}

const magic = [2]u8{ 0xB0, 0x0B };
fn saveScore() !void {
    var buffer: [1024]u8 = undefined;
    var stream = std.Io.fixedBufferStream(&buffer);
    var writer = stream.writer();
    try writer.writeAll(&magic);
    //  游戏版本号
    try writer.writeAll(&.{ 0x00, 0x00 });
    for (scoreBoard[0..scoreCount]) |value| {
        const len: u8 = @intCast(value.name.len);
        try writer.writeByte(len); // 写入长度
        try writer.writeAll(value.name); // 写入名字
        try writer.writeAll(std.mem.asBytes(&value.score)); // 写入分数
    }

    try window.saveAll("save/score.dat", buffer[0..stream.pos]);
}

fn loadScore() !void {
    var buffer: [1024]u8 = undefined;
    const slice = try window.readAll("save/score.dat", &buffer);
    var stream = std.io.fixedBufferStream(slice);
    var reader = stream.reader();

    // 1. magic
    var magicBuf: [magic.len]u8 = undefined;
    try reader.readNoEof(&magicBuf);
    if (!std.mem.eql(u8, &magicBuf, &magic)) return;

    // 2. 游戏版本号
    var version: [2]u8 = undefined;
    try reader.readNoEof(&version);

    while (true) {
        const readLen = reader.readByte() catch |e| { // 读取长度
            if (e == error.EndOfStream) return;
            return e;
        };
        // 读取名字
        const len = try reader.readAll(nameBuffer[0..readLen]);
        const score = try reader.readInt(u32, .little); // 读取分数
        const n = window.dupe(u8, nameBuffer[0..len]);
        scoreBoard[scoreCount] = .{ .name = n, .score = score };
        scoreCount += 1;
    }
}

pub fn deinit() void {
    for (scoreBoard[0..scoreCount]) |score| {
        window.free(score.name);
    }
}
```

## 效果

![保存和读取得分][1]

[1]: images/太空战机26.gif

## 附录
