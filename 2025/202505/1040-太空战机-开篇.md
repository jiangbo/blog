# 1040-太空战机-开篇

## 目标

根据 B 站上一位教游戏开发的老师，学习开发一个太空战机游戏。

## 环境

- Time 2025-12-03
- Zig 0.15.1

## 参考

1. <https://www.bilibili.com/video/BV1wSCFYQEyc>

## 想法

没有使用 CPP 语言来进行开发，使用的 Zig 语言和自己做的小引擎。

## main.zig

打开一个窗口，设置的分辨率对于我的显示器太大了，缩小了一点。

```zig
const std = @import("std");
const builtin = @import("builtin");

const window = @import("zhu").window;
const scene = @import("scene.zig");

pub extern "Imm32" fn ImmDisableIME(i32) std.os.windows.BOOL;

pub fn init() void {
    scene.init();
}

pub fn frame(delta: f32) void {
    scene.update(delta);
    scene.draw();
}

pub fn deinit() void {
    scene.deinit();
}

pub fn main() void {
    var allocator: std.mem.Allocator = undefined;
    var debugAllocator: std.heap.DebugAllocator(.{}) = undefined;
    if (builtin.mode == .Debug) {
        debugAllocator = std.heap.DebugAllocator(.{}).init;
        allocator = debugAllocator.allocator();
    } else {
        allocator = std.heap.c_allocator;
    }

    defer if (builtin.mode == .Debug) {
        _ = debugAllocator.deinit();
    };

    if (builtin.os.tag == .windows) {
        _ = ImmDisableIME(-1);
    }

    window.run(allocator, .{
        .title = "太空战机",
        .logicSize = .{ .x = 600, .y = 800 },
        .scale = 0.75,
    });
}
```

## scene.zig

把之前场景中不需要的删除了，然后直接拷贝过来。

```zig
const std = @import("std");
const zhu = @import("zhu");

const window = zhu.window;
const gfx = zhu.gfx;
const camera = zhu.camera;

var isHelp = false;
var isDebug = false;
var vertexBuffer: []camera.Vertex = undefined;

pub fn init() void {
    vertexBuffer = window.alloc(camera.Vertex, 5000);
    camera.frameStats(true);
    camera.init(vertexBuffer);
}

pub fn update(_: f32) void {
    if (window.isKeyRelease(.H)) isHelp = !isHelp;
    if (window.isKeyRelease(.X)) isDebug = !isDebug;

    if (window.isKeyDown(.LEFT_ALT) and window.isKeyRelease(.ENTER)) {
        return window.toggleFullScreen();
    }
}

pub fn draw() void {
    // camera.beginDraw(.{});
    // defer camera.endDraw();

    // window.keepAspectRatio();
    // sceneCall("draw", .{});

    // if (isHelp) drawHelpInfo() else if (isDebug) drawDebugInfo();
}

fn drawHelpInfo() void {
    const text =
        \\按键说明：
        \\上：W，下：S，左：A，右：D
        \\确定：F，取消：Q，菜单：E
        \\帮助：H  按一次打开，再按一次关掉
    ;
    var iterator = std.unicode.Utf8View.initUnchecked(text).iterator();
    var count: u32 = 0;
    while (iterator.nextCodepoint()) |code| {
        if (code == '\n') continue;
        count += 1;
    }
    debutTextCount = count;

    camera.drawColorText(text, .init(10, 5), .green);
}

var debutTextCount: u32 = 0;
fn drawDebugInfo() void {
    var buffer: [1024]u8 = undefined;
    const format =
        \\后端：{s}
        \\帧率：{}
        \\帧时：{d:.2}
        \\用时：{d:.2}
        \\显存：{}
        \\常量：{}
        \\绘制：{}
        \\图片：{}
        \\文字：{}
        \\内存：{}
        \\鼠标：{d:.2}，{d:.2}
        \\相机：{d:.2}，{d:.2}
    ;

    const stats = camera.queryFrameStats();
    const text = zhu.format(&buffer, format, .{
        @tagName(camera.queryBackend()),
        window.frameRate,
        window.frameDeltaPerSecond,
        window.usedDeltaPerSecond,
        stats.size_append_buffer + stats.size_update_buffer,
        stats.size_apply_uniforms,
        stats.num_draw,
        camera.imageDrawCount(),
        // Debug 信息本身的次数也应该统计进去
        camera.textDrawCount() + debutTextCount,
        window.countingAllocator.used,
        window.mousePosition.x,
        window.mousePosition.y,
        camera.position.x,
        camera.position.y,
    });

    var iterator = std.unicode.Utf8View.initUnchecked(text).iterator();
    var count: u32 = 0;
    while (iterator.nextCodepoint()) |code| {
        if (code == '\n') continue;
        count += 1;
    }
    debutTextCount = count;

    camera.drawColorText(text, .init(10, 5), .green);
}

pub fn deinit() void {
    sceneCall("deinit", .{});
    window.free(vertexBuffer);
}

fn sceneCall(comptime function: []const u8, args: anytype) void {
    _ = function;
    _ = args;
}
```

## 效果

![打开窗口][1]

[1]: images/太空战机01.png

## 附录
