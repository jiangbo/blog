# 1021-地宫探险-游戏胜利界面

## 目标

找到护符后，游戏胜利，然后可以按 1 重新开始游戏。

## 环境

- Time 2025-11-14
- Zig 0.15.1

## 参考

1. <https://pragprog.com/titles/hwrust/hands-on-rust/>
2. 《Rust游戏开发实战》

## 想法

之前实现的 ECS 中的删除数据方法好像有点问题，然后修复了一下，有问题再修改。

## item.zig

物品模块，目前只有一个护符的物品。

```zig
const std = @import("std");
const zhu = @import("zhu");

const gfx = zhu.gfx;
const ecs = zhu.ecs;

const map = @import("map.zig");
const component = @import("component.zig");

const TilePosition = component.TilePosition;
const Amulet = component.Amulet;

pub fn init() void {
    const amulet = ecs.w.createIdentityEntity(Amulet);

    const last = map.rooms[map.rooms.len - 1].center();
    ecs.w.add(amulet, last);
    const texture = map.getTextureFromTile(.amulet);
    ecs.w.alignAdd(amulet, .{ map.worldPosition(last), texture });
}
```

## player.zig

玩家模块，重构了一下。

```zig
const std = @import("std");
const zhu = @import("zhu");

const gfx = zhu.gfx;
const window = zhu.window;
const camera = zhu.camera;
const ecs = zhu.ecs;

const map = @import("map.zig");
const battle = @import("battle.zig");
const component = @import("component.zig");

const Player = component.Player;
const Enemy = component.Enemy;
const WantToAttack = component.WantToAttack;
const Health = component.Health;
const TurnState = component.TurnState;
const Position = component.Position;
const TilePosition = component.TilePosition;
const Amulet = component.Amulet;

var entity: ecs.Entity = undefined;

pub fn init() void {
    entity = ecs.w.createIdentityEntity(Player);

    const tilePosition = map.rooms[0].center();
    ecs.w.add(entity, tilePosition);
    ecs.w.add(entity, map.getTextureFromTile(.player));
    ecs.w.add(entity, map.worldPosition(tilePosition));
    const health: Health = .{ .max = 10, .current = 10 };
    ecs.w.add(entity, health);

    cameraFollow(map.worldPosition(tilePosition));
}

pub fn update() void {
    if (!window.isAnyRelease()) return; // 没有按任何键

    if (window.isKeyRelease(.SPACE)) {
        // 空格跳过当前回合
        ecs.w.addContext(TurnState.monster);
        var health = ecs.w.getPtr(entity, Health).?;
        health.current = @min(health.max, health.current + 1);
        return;
    }

    const tilePosition = ecs.w.get(entity, TilePosition).?;
    var newPos = tilePosition;
    if (window.isKeyRelease(.W)) newPos.y -|= 1 //
    else if (window.isKeyRelease(.S)) newPos.y += 1 //
    else if (window.isKeyRelease(.A)) newPos.x -|= 1 //
    else if (window.isKeyRelease(.D)) newPos.x += 1; //

    if (tilePosition.equals(newPos)) return; // 没有移动

    const amuletPos = ecs.w.getIdentity(Amulet, TilePosition).?;
    if (amuletPos.equals(newPos)) {
        ecs.w.addContext(TurnState.win);
    } else moveOrAttack(newPos);

    battle.attack();
}

fn moveOrAttack(newPos: TilePosition) void {
    ecs.w.addContext(TurnState.monster);
    if (!map.canMove(newPos)) return; // 不能移动，撞墙也算移动

    var view = ecs.w.view(.{ Enemy, TilePosition });
    while (view.next()) |enemy| {
        const position = view.get(enemy, TilePosition);
        if (!newPos.equals(position)) continue;

        const enemyEntity = ecs.w.toEntity(enemy).?;
        ecs.w.add(entity, WantToAttack{enemyEntity});
        return;
    }

    ecs.w.add(entity, newPos);
    ecs.w.add(entity, map.worldPosition(newPos));
    map.updateDistance(newPos);
    cameraFollow(map.worldPosition(newPos));
}

fn cameraFollow(position: Position) void {
    const scaleSize = window.logicSize.div(camera.scale);
    const half = scaleSize.scale(0.5);
    const max = map.size.sub(scaleSize).max(.zero);
    camera.position = position.sub(half).clamp(.zero, max);
}
```

## 效果

![游戏胜利界面][1]

[1]: images/地宫探险16.gif

## 附录
