# 1018-地宫探险-更聪明的怪兽

## 目标

给怪兽添加了一个追踪玩家的组件，目前可以对玩家进行追踪。

## 环境

- Time 2025-11-07
- Zig 0.15.1

## 参考

1. <https://pragprog.com/titles/hwrust/hands-on-rust/>
2. 《Rust游戏开发实战》

## 想法

在地图上追踪玩家的算法是自己的写的，不太聪明，暂时先用着。

## map.zig

地图模块新增了地图上距离的计算，方便怪兽追踪玩家的位置。

```zig
var distances: [HEIGHT][WIDTH]u8 = undefined;
const Dequeue = std.PriorityDequeue(TilePosition, void, struct {
    fn compare(_: void, a: TilePosition, b: TilePosition) std.math.Order {
        return std.math.order(distances[a.y][a.x], distances[b.y][b.x]);
    }
}.compare);
const directions: [4]TilePosition = .{
    .{ .x = 1, .y = 0 }, .{ .x = 0xFF, .y = 0 },
    .{ .x = 0, .y = 1 }, .{ .x = 0, .y = 0xFF },
};
pub fn updateDistance(pos: TilePosition) void {
    for (&distances) |*row| @memset(row, 0xFF);

    var queue = Dequeue.init(window.allocator, {});
    defer queue.deinit();

    distances[pos.y][pos.x] = 0;
    queue.add(pos) catch unreachable;

    while (queue.removeMinOrNull()) |min| {
        const distance = distances[min.y][min.x];

        for (directions) |dir| {
            const x, const y = .{ min.x +% dir.x, min.y +% dir.y };
            if (x >= WIDTH or y >= HEIGHT) continue; // 超过地图
            if (tiles[indexUsize(x, y)] != .floor) continue; // 不可通过

            if (distance + 1 < distances[y][x]) {
                distances[y][x] = distance + 1;
                queue.add(.{ .x = x, .y = y }) catch unreachable;
            }
        }
    }
}

pub fn queryLessDistance(pos: TilePosition) ?TilePosition {
    const distance = distances[pos.y][pos.x];
    if (distance == 0) return null;

    for (directions) |dir| {
        const x, const y = .{ pos.x +% dir.x, pos.y +% dir.y };

        if (x >= WIDTH or y >= HEIGHT) continue; // 超过地图
        if (distances[y][x] < distance) {
            return .{ .x = x, .y = y };
        }
    }
    return null;
}
```

## monster.zig

没有使用随机移动了，使用的追踪玩家。

```zig
const std = @import("std");
const zhu = @import("zhu");

const ecs = zhu.ecs;
const gfx = zhu.gfx;

const map = @import("map.zig");
const component = @import("component.zig");

const Player = component.Player;
const Enemy = component.Enemy;
const Health = component.Health;
const Name = component.Name;
const TurnState = component.TurnState;
const TilePosition = component.TilePosition;
const WantToMove = component.WantToMove;
const WantToAttack = component.WantToAttack;
const ChasePlayer = component.ChasePlayer;

const MovingRandomly = struct {};

pub fn init() void {
    for (map.rooms[1..]) |room| {
        const enemy = ecs.w.createEntity();

        const center = room.center();
        ecs.w.add(enemy, center);
        ecs.w.add(enemy, map.worldPosition(center));

        const enemyTile = switch (zhu.randomIntMost(u8, 1, 10)) {
            0...8 => map.Tile.goblin,
            else => map.Tile.orc,
        };

        const hp: i32 = switch (enemyTile) {
            map.Tile.goblin => 1,
            map.Tile.orc => 2,
            else => unreachable,
        };
        ecs.w.add(enemy, Health{ .current = hp, .max = hp });
        ecs.w.add(enemy, Name{@tagName(enemyTile)});

        ecs.w.add(enemy, map.getTextureFromTile(enemyTile));
        ecs.w.add(enemy, ChasePlayer{});
        ecs.w.add(enemy, Enemy{});
    }
}

pub fn move() void {
    if (ecs.w.getContext(TurnState).?.* != .player) return;

    const playerEntity = ecs.w.getIdentityEntity(Player).?;
    const playerPos = ecs.w.get(playerEntity, TilePosition).?;

    ecs.w.addContext(TurnState.monster);
    var view = ecs.w.view(.{ ChasePlayer, TilePosition });
    while (view.next()) |entity| {
        const pos = view.get(entity, TilePosition);
        const next = map.queryLessDistance(pos) orelse continue;

        if (playerPos.equals(next)) {
            view.add(entity, WantToAttack{playerEntity});
        } else {
            view.add(entity, WantToMove{next});
        }
    }
}
```

## 效果

![更聪明的怪兽][1]

[1]: images/地宫探险13.gif

## 附录
