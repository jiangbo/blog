# 1023-地宫探险-忽略视野外怪兽

## 目标

绘制的时候，之前如果怪兽在视野之外，也会被绘制出来，如果在视野外，则不应该绘制。

## 环境

- Time 2025-11-19
- Zig 0.15.1

## 参考

1. <https://pragprog.com/titles/hwrust/hands-on-rust/>
2. 《Rust游戏开发实战》

## 想法

增加了一个角色视野组件，只绘制角色能看到的怪兽。

## component.zig

```zig
const std = @import("std");
const zhu = @import("zhu");

const ecs = zhu.ecs;

pub const Position = zhu.gfx.Vector;
pub const Texture = zhu.gfx.Texture;
pub const TurnState = enum { player, monster, over, win };
pub const Health = struct { current: i32, max: i32 };
pub const Name = struct { []const u8 };
pub const Player = struct {};
pub const Enemy = struct {};
pub const ChasePlayer = struct {};
pub const Amulet = struct {};

pub const Tile = enum(u8) {
    other = 0,
    wall = 35,
    floor = 46,
    player = 64,
    ettin = 69,
    ogre = 79,
    goblin = 103,
    orc = 111,
    amulet = 124,
};

pub const TilePosition = struct {
    x: u8,
    y: u8,
    pub fn equals(self: TilePosition, other: TilePosition) bool {
        return self.x == other.x and self.y == other.y;
    }
};
pub const TileRect = struct {
    x: u8,
    y: u8,
    w: u8,
    h: u8,

    pub fn intersect(r1: TileRect, r2: TileRect) bool {
        return r1.x < r2.x + r2.w and r1.x + r1.w > r2.x and
            r1.y < r2.y + r2.h and r1.y + r1.h > r2.y;
    }

    pub fn center(r: TileRect) TilePosition {
        return .{ .x = r.x + r.w / 2, .y = r.y + r.h / 2 };
    }

    pub fn fromCenter(c: TilePosition, w: u8, h: u8) TileRect {
        return .{
            .x = c.x -| w,
            .y = c.y -| h,
            .w = 2 * w + 1,
            .h = 2 * h + 1,
        };
    }

    pub fn contains(self: TileRect, pos: TilePosition) bool {
        return self.x <= pos.x and pos.x < self.x + self.w and
            self.y <= pos.y and pos.y < self.y + self.h;
    }
};
pub const WantToMove = struct { TilePosition };
pub const WantToAttack = struct { ecs.Entity };
pub const ViewField = struct { TileRect };
pub const PlayerView = struct {};
```

## monster.zig

给怪兽增加了一个角色的视野组件，如果能被角色看到的话。

```zig
fn moveOrAttack() void {
    const playerEntity = ecs.w.getIdentityEntity(Player).?;
    const playerPos = ecs.w.get(playerEntity, TilePosition).?;
    const rect = ecs.w.get(playerEntity, ViewField).?[0];

    var view = ecs.w.view(.{ ChasePlayer, TilePosition });
    while (view.next()) |entity| {
        var pos = view.get(entity, TilePosition);
        const next = map.queryLessDistance(pos) orelse continue;

        if (rect.contains(next)) view.add(entity, PlayerView{});
        if (playerPos.equals(next)) {
            view.add(entity, WantToAttack{playerEntity});
            continue;
        }

        for (ecs.w.raw(TilePosition)) |tilePos| {
            if (!tilePos.equals(next)) continue;

            const step = zhu.math.randomStep(u8, 1);
            if (pos.x == next.x) pos.x +%= step else pos.y +%= step;
            view.add(entity, WantToMove{pos});
            break;
        } else view.add(entity, WantToMove{next});
    }
}
```

## scene.zig

绘制时，根据角色视野组件来绘制。

```zig
pub fn draw() void {
    camera.beginDraw(.{});
    defer camera.endDraw();

    window.keepAspectRatio();
    sceneCall("draw", .{});
    map.draw();

    var view = ecs.w.view(.{ gfx.Texture, Position, PlayerView });
    while (view.next()) |entity| {
        const pos = view.get(entity, Position);
        camera.draw(view.get(entity, gfx.Texture), pos);
    }

    hud.draw();

    if (isHelp) drawHelpInfo() else if (isDebug) drawDebugInfo();
}
```

## 效果

![忽略视野外怪兽][1]

[1]: images/地宫探险18.gif

## 附录
