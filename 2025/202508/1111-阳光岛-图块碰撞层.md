# 1111-阳光岛-图块碰撞层

## 目标

加载了地图中的碰撞信息，现在角色可以和地图中的碰撞层交互。

## 环境

- Time 2026-01-24
- Zig 0.15.1

## 参考

1. <https://www.bilibili.com/video/BV1jf9XYQEhW>

## 想法

实现和图块的碰撞，好像有点问题，不过先就这样，遇到问题再来修改。

## player.zig

检查角色在地图中是否碰撞。

```zig
const std = @import("std");
const zhu = @import("zhu");

const tiled = zhu.extend.tiled;

const map = @import("map.zig");

const moveForce = 200; // 移动力
const factor = 0.85; // 减速因子
const maxSpeed = 120; // 最大速度
const gravity = 980; // 重力

const size: zhu.Vector2 = .xy(32, 32);
var image: zhu.graphics.Image = undefined;

var force: zhu.Vector2 = .xy(0, gravity);
var velocity: zhu.Vector2 = .zero;
pub var position: zhu.Vector2 = undefined;
var state: State = .idle;

pub fn init(pos: zhu.Vector2) void {
    position = pos;
    const foxy = zhu.getImage("textures/Actors/foxy.png");
    image = foxy.sub(.init(.zero, size));
    state.enter();
}

pub fn update(delta: f32) void {
    state.update(delta);

    velocity = velocity.add(force.scale(delta));
    velocity.x = std.math.clamp(velocity.x, -maxSpeed, maxSpeed);
    const toPosition = position.add(velocity.scale(delta));

    const clamped = map.clamp(position, toPosition, size);
    std.log.info("old: {}, new: {}, clamped: {}", .{ position, toPosition, clamped });
    if (clamped.x == position.x) velocity.x = 0;
    if (clamped.y == position.y) velocity.y = 0;
    position = clamped;
}

pub fn draw() void {
    zhu.batch.drawImage(image, position, .{
        .flipX = velocity.x < 0,
    });
}

const State = union(enum) {
    idle: IdleState,
    walk: WalkState,
    // jump: JumpState,
    // fall: FallState,

    fn enter(self: State) void {
        switch (self) {
            inline else => |case| @TypeOf(case).enter(),
        }
    }

    fn update(self: State, delta: f32) void {
        switch (self) {
            inline else => |case| @TypeOf(case).update(delta),
        }
    }

    fn draw(self: State) void {
        switch (self) {
            inline else => |case| @TypeOf(case).draw(),
        }
    }
};

fn changeState(newState: State) void {
    state = newState;
    state.enter();
}

const IdleState = struct {
    fn enter() void {
        std.log.info("enter idle", .{});
    }

    fn update(_: f32) void {
        if (zhu.window.isAnyKeyDown(&.{ .A, .D })) {
            changeState(.walk);
        } else velocity.x *= factor; // 减速
    }
};

const WalkState = struct {
    fn enter() void {
        std.log.info("enter walk", .{});
    }

    fn update(_: f32) void {
        if (zhu.window.isKeyDown(.A)) {
            if (velocity.x > 0) velocity.x = 0;
            force.x = -moveForce;
        } else if (zhu.window.isKeyDown(.D)) {
            if (velocity.x < 0) velocity.x = 0;
            force.x = moveForce;
        } else {
            force.x = 0;
            changeState(.idle);
        }
    }
};
const JumpState = struct {};
const FallState = struct {};
```

## map.zig

实现了 clamp 方法，可以将角色的坐标放到正确的位置。

```zig
const std = @import("std");
const zhu = @import("zhu");

const window = zhu.window;
const batch = zhu.batch;
const tiled = zhu.extend.tiled;
const Vector2 = zhu.Vector2;

const level: tiled.Map = @import("zon/level1.zon");
var tileVertexes: std.ArrayList(batch.Vertex) = .empty;
var tiles: std.ArrayList(tiled.Tile) = .empty;

pub var playerStart: zhu.Vector2 = .zero;

pub fn init() void {
    for (level.layers) |layer| {
        if (layer.type == .tile) parseTileLayer(&layer) //
        else if (layer.type == .object) parseObjectLayer(&layer);
    }
}

pub fn deinit() void {
    tiles.deinit(zhu.assets.allocator);
    tileVertexes.deinit(zhu.assets.allocator);
}

fn parseTileLayer(layer: *const tiled.Layer) void {
    var firstImage = zhu.assets.getImage(level.tileSets[0].images[0]);
    for (layer.data, 0..) |tileIndex, index| {
        if (tileIndex == 0) continue;

        const tileSet = blk: for (level.tileSets) |tileSet| {
            if (tileIndex < tileSet.max) break :blk tileSet;
        } else unreachable;

        const x: f32 = @floatFromInt(index % level.width);
        const y: f32 = @floatFromInt(index / level.width);
        var pos = level.tileSize.mul(.xy(x, y));

        var image: zhu.graphics.Image = undefined;
        const id = tileIndex - tileSet.min;
        const columns = tileSet.columns; // 单图片瓦片集的列数
        if (columns == 0) {
            image = zhu.assets.getImage(tileSet.images[id]);
            pos.y = pos.y - image.area.size.y + level.tileSize.y;
        } else {
            const area = tiled.tileArea(id, level.tileSize, columns);
            image = firstImage.sub(area);
        }

        tileVertexes.append(zhu.assets.allocator, .{
            .position = pos,
            .size = image.area.size,
            .texturePosition = image.area.toTexturePosition(),
        }) catch @panic("oom, can't append tile");
    }
}

fn parseObjectLayer(layer: *const tiled.Layer) void {
    for (layer.objects) |object| {
        const tileSet = blk: for (level.tileSets) |tileSet| {
            if (object.gid < tileSet.max) break :blk tileSet;
        } else unreachable;

        const id = object.gid - tileSet.min;
        if (id == 1) {
            // 角色，目前特殊处理一下，后续想想角色应该加入到地图还是单独管理
            playerStart = object.position.addY(-object.size.y);
            continue;
        }
        const image = zhu.assets.getImage(tileSet.images[id]);

        tiles.append(zhu.assets.allocator, .{
            .image = image.sub(.init(.zero, object.size)),
            .position = object.position.addY(-object.size.y),
        }) catch @panic("oom, can't append tile");
    }
}

pub fn worldToTilePosition(pos: zhu.Vector2) tiled.Position {
    const tilePos = pos.div(level.tileSize).floor();
    const x: u32 = @intFromFloat(tilePos.x);
    const y: u32 = @intFromFloat(tilePos.y);
    return .{ .x = x, .y = y };
}

pub fn worldToTileIndex(pos: zhu.Vector2) usize {
    const tilePos = worldToTilePosition(pos);
    if (tilePos.x < 0 or tilePos.y < 0) return 0;
    if (tilePos.x >= level.width or tilePos.y >= level.height) return 0;
    return tilePos.y * level.width + tilePos.x;
}

pub fn tileIndexToWorld(index: usize) zhu.Vector2 {
    const x: f32 = @floatFromInt(index % level.width);
    const y: f32 = @floatFromInt(index / level.width);
    return level.tileSize.mul(.xy(x, y));
}

pub fn clamp(old: Vector2, new: Vector2, size: Vector2) Vector2 {
    const clampedX = clampX(old, .xy(new.x, old.y), size);
    const clampedY = clampY(old, .xy(old.x, new.y), size);
    return .xy(clampedX.x, clampedY.y);
}

const epsilon = zhu.Vector2.one.scale(-zhu.math.epsilon);
fn clampX(old: Vector2, new: Vector2, size: Vector2) Vector2 {
    const sz = size.add(epsilon);

    if (new.x < old.x) { // 向左移动
        var tileIndex = worldToTileIndex(new);
        if (level.states[tileIndex] == 1) { // 左上角碰撞
            return tileIndexToWorld(tileIndex + 1);
        }
        tileIndex = worldToTileIndex(new.addY(sz.y));
        if (level.states[tileIndex] == 1) { // 左下角碰撞
            return tileIndexToWorld(tileIndex + 1);
        }
    } else if (new.x > old.x) { // 向右移动
        const offset = level.tileSize.x - size.x;
        var tileIndex = worldToTileIndex(new.addX(sz.x));
        if (level.states[tileIndex] == 1) { // 右上角碰撞
            return tileIndexToWorld(tileIndex - 1).addX(offset);
        }
        tileIndex = worldToTileIndex(new.add(sz));
        if (level.states[tileIndex] == 1) { // 右下角碰撞
            return tileIndexToWorld(tileIndex - 1).addX(offset);
        }
    }
    return new;
}

fn clampY(old: Vector2, new: Vector2, size: Vector2) Vector2 {
    const w = level.width;

    const sz = size.add(epsilon);
    if (new.y < old.y) { // 向上移动
        var tileIndex = worldToTileIndex(new);
        if (level.states[tileIndex] == 1) { // 左上角碰撞
            return tileIndexToWorld(tileIndex + w);
        }
        tileIndex = worldToTileIndex(new.addX(sz.x));
        if (level.states[tileIndex] == 1) { // 右上角碰撞
            return tileIndexToWorld(tileIndex + w);
        }
    } else if (new.y > old.y) { // 向下移动
        var tileIndex = worldToTileIndex(new.addY(sz.y));
        const offset = level.tileSize.y - size.y;
        if (level.states[tileIndex] == 1) {
            return tileIndexToWorld(tileIndex - w).addY(offset);
        }

        tileIndex = worldToTileIndex(new.add(sz));
        if (level.states[tileIndex] == 1) {
            return tileIndexToWorld(tileIndex - w).addY(offset);
        }
    }
    return new;
}

pub fn draw() void {
    for (level.layers) |*layer| {
        if (layer.type == .image) drawImageLayer(layer);
    }

    batch.vertexBuffer.appendSliceAssumeCapacity(tileVertexes.items);

    for (tiles.items) |tile| {
        batch.drawImage(tile.image, tile.position, .{});
    }

    for (0..level.height) |y| {
        for (0..level.width) |x| {
            const index = y * level.width + x;
            const state = level.states[index];
            if (state == 0) continue;

            const pos = level.tileSize.mul(.xy(@floatFromInt(x), @floatFromInt(y)));
            batch.debugDraw(.init(pos, level.tileSize));
        }
    }
}

fn drawImageLayer(layer: *const tiled.Layer) void {
    zhu.camera.modeEnum = .window;
    defer zhu.camera.modeEnum = .world;

    if (layer.repeatY) {
        const posY = zhu.camera.position.y * layer.parallaxY;
        var y = -@mod(posY, layer.height);
        while (y < window.size.y) : (y += layer.height) {
            batch.draw(layer.image, layer.offset.addXY(0, y));
        }
    }

    if (layer.repeatX) {
        const posX = zhu.camera.position.x * layer.parallaxX;
        var x = -@mod(posX, layer.width);
        while (x < window.size.x) : (x += layer.width) {
            batch.draw(layer.image, layer.offset.addXY(x, 0));
        }
    }
}
```

## 效果

![图块碰撞层][1]

[1]: images/阳光岛09.gif

## 附录
