# 1134-阳光岛-进入下一关

## 目标

当角色走到关卡尽头时，进入下一关，切换地图。

## 环境

- Time 2026-01-30
- Zig 0.15.1

## 参考

1. <https://www.bilibili.com/video/BV1jf9XYQEhW>

## 想法

把切换地图的区域解析到 map 模块，角色移动后检查一下是否碰撞就可以了。

## map.zig

```zig
const std = @import("std");
const zhu = @import("zhu");

const window = zhu.window;
const batch = zhu.batch;
const tiled = zhu.extend.tiled;
const Vector2 = zhu.Vector2;

pub const ObjectEnum = enum(u32) {
    player = zhu.imageId("textures/Actors/foxy.png"),
    eagle = zhu.imageId("textures/Actors/eagle-attack.png"),
    frog = zhu.imageId("textures/Actors/frog.png"),
    opossum = zhu.imageId("textures/Actors/opossum.png"),
    skull = zhu.imageId("textures/Props/skulls.png"),
    spike = zhu.imageId("textures/Props/spikes.png"),
    spikeTop = zhu.imageId("textures/Props/spikes-top.png"),
    cherry = zhu.imageId("textures/Items/cherry.png"),
    gem = zhu.imageId("textures/Items/gem.png"),
};

pub const TileEnum = enum { normal, solid, uniSolid, ladder };

pub const Object = struct {
    type: ObjectEnum,
    initPosition: Vector2 = .zero,
    position: Vector2,
    velocity: Vector2 = .zero,
    size: Vector2,
    object: ?tiled.Object,
};
const maps: []const tiled.Map = @import("zon/level.zon");
var map = maps[0];
const tileSets: []const tiled.TileSet = @import("zon/tile.zon");
var tileVertexes: std.ArrayList(batch.Vertex) = .empty;
pub var objects: std.ArrayList(Object) = .empty;
var tileStates: []TileEnum = &.{};

pub var nextLevelArea: ?zhu.Rect = null;

pub fn init(level: u8) void {
    tiled.tileSets = tileSets;

    if (tileStates.len != 0) { // 如果存在之前的数据，则先释放
        zhu.assets.free(tileStates);
        tileVertexes.clearRetainingCapacity();
        objects.clearRetainingCapacity();
        nextLevelArea = null;
    }

    map = maps[level];

    tileStates = zhu.assets.oomAlloc(TileEnum, map.width * map.height);
    @memset(tileStates, .normal);
    batch.camera.bound = map.size();

    for (map.layers) |layer| {
        if (layer.type == .tile) parseTileLayer(&layer) //
        else if (layer.type == .object) parseObjectLayer(&layer);
    }
}

pub fn deinit() void {
    objects.deinit(zhu.assets.allocator);
    tileVertexes.deinit(zhu.assets.allocator);
    zhu.assets.free(tileStates);
}

fn parseTileLayer(layer: *const tiled.Layer) void {
    const firstTileSet = tiled.getTileSetByRef(map.tileSetRefs[0]);
    var firstImage = zhu.assets.getImage(firstTileSet.image);
    for (layer.data, 0..) |gid, index| {
        if (gid == 0) continue;

        const x: f32 = @floatFromInt(index % map.width);
        const y: f32 = @floatFromInt(index / map.width);
        var pos = map.tileSize.mul(.xy(x, y));

        var image: zhu.graphics.Image = undefined;
        const tileSetRef = map.getTileSetRefByGid(gid);
        const tileSet = tiled.getTileSetByRef(tileSetRef);
        const localId = gid - tileSetRef.firstGid;

        const tile = tileSet.getTileByLocalId(localId);
        if (tileSet.columns == 0) { // 单图片瓦片集的列数
            image = zhu.assets.getImage(tile.?.id);
            pos.y = pos.y - image.area.size.y + map.tileSize.y;
            if (tile.?.id == @intFromEnum(ObjectEnum.spike)) {
                parseTileSpike(tile.?, pos);
            }
        } else {
            const area = map.tileArea(localId, tileSet.columns);
            image = firstImage.sub(area);
        }

        tileVertexes.append(zhu.assets.allocator, .{
            .position = pos,
            .size = image.area.size,
            .texturePosition = image.area.toTexturePosition(),
        }) catch @panic("oom, can't append tile");

        if (tile) |t| parseProperties(index, t); // 解析碰撞信息
    }
}

fn parseTileSpike(tile: tiled.Tile, pos: zhu.Vector2) void {
    const object = tile.objectGroup.?.objects[0];
    objects.append(zhu.assets.allocator, .{
        .type = @enumFromInt(tile.id),
        .position = pos,
        .initPosition = pos,
        .size = object.size,
        .object = object,
    }) catch @panic("oom, can't append tile");
}

fn parseProperties(index: usize, tile: tiled.Tile) void {
    for (tile.properties) |property| {
        if (std.mem.eql(u8, property.name, "solid")) {
            if (property.value.bool) tileStates[index] = .solid;
        } else if (std.mem.eql(u8, property.name, "unisolid")) {
            if (property.value.bool) tileStates[index] = .uniSolid;
        } else if (std.mem.eql(u8, property.name, "ladder")) {
            if (property.value.bool) tileStates[index] = .ladder;
        } else tileStates[index] = .normal;
    }
}

fn parseObjectLayer(layer: *const tiled.Layer) void {
    for (layer.objects) |object| {
        if (object.gid == 0) {
            if (object.properties.len != 0) {
                const property = object.properties[0];
                if (std.mem.eql(u8, property.name, "tag") and
                    std.mem.eql(u8, property.value.string, "next_level"))
                {
                    nextLevelArea = zhu.Rect{
                        .min = object.position,
                        .size = object.size,
                    };
                }
            } else std.log.info("gid 0, position: {}", .{object.position});
            continue;
        }
        const tile = map.getTileByGId(object.gid).?;

        var obj: ?tiled.Object = null;
        if (tile.objectGroup) |group| obj = group.objects[0];
        objects.append(zhu.assets.allocator, .{
            .type = @enumFromInt(tile.id),
            .position = object.position.addY(-object.size.y),
            .initPosition = object.position.addY(-object.size.y),
            .size = object.size,
            .object = obj,
        }) catch @panic("oom, can't append tile");
    }
}

pub fn isTouchLadder(pos: Vector2, size: Vector2) bool {
    const topLeft = pos;
    const topRight = pos.addX(size.x);
    const bottomLeft = pos.addY(size.y);
    const bottomRight = pos.add(size);

    return tileStates[map.worldToTileIndex(topLeft)] == .ladder or
        tileStates[map.worldToTileIndex(topRight)] == .ladder or
        tileStates[map.worldToTileIndex(bottomLeft)] == .ladder or
        tileStates[map.worldToTileIndex(bottomRight)] == .ladder;
}

pub fn isTopLadder(pos: Vector2, size: Vector2) bool {
    const centerX = pos.x + size.x / 2;
    const point = zhu.Vector2.xy(centerX, pos.y + size.y);
    return tileStates[map.worldToTileIndex(point)] == .ladder;
}

pub fn canClimb(pos: Vector2, size: Vector2) bool {
    const bottomLeft = pos.addY(size.y);
    const bottomRight = pos.add(size);

    return tileStates[map.worldToTileIndex(bottomLeft)] == .ladder and
        tileStates[map.worldToTileIndex(bottomRight)] == .ladder;
}

pub fn clamp(old: Vector2, new: Vector2, size: Vector2) Vector2 {
    const newX = zhu.Vector2.xy(new.x, old.y);
    const clampedX = if (new.x < old.x) clampLeft(newX, size) //
        else if (new.x > old.x) clampRight(newX, size) else newX;

    const newY = zhu.Vector2.xy(old.x, new.y);
    const clampedY = if (new.y < old.y) clampUp(newY, size) //
        else if (new.y > old.y) clampDown(newY, size) else newY;

    return .xy(clampedX.x, clampedY.y);
}

const epsilon = zhu.Vector2.one.scale(-zhu.math.epsilon);
fn clampLeft(new: Vector2, size: Vector2) Vector2 {
    const sz = size.add(epsilon);

    var tileIndex = map.worldToTileIndex(new);
    if (tileStates[tileIndex] == .solid) { // 左上角碰撞
        return map.tileIndexToWorld(tileIndex + 1);
    }

    const bottomLeft = new.addY(sz.y);
    tileIndex = map.worldToTileIndex(bottomLeft);
    if (tileStates[tileIndex] == .solid) { // 左下角碰撞
        return map.tileIndexToWorld(tileIndex + 1);
    }
    return new;
}

fn clampRight(new: Vector2, size: Vector2) Vector2 {
    const sz = size.add(epsilon);

    var tileIndex = map.worldToTileIndex(new.addX(sz.x));
    const offsetX = map.tileSize.x - size.x;
    if (tileStates[tileIndex] == .solid) { // 右上角碰撞
        return map.tileIndexToWorld(tileIndex - 1).addX(offsetX);
    }

    const bottomRight = new.add(sz);
    tileIndex = map.worldToTileIndex(bottomRight);
    if (tileStates[tileIndex] == .solid) { // 右下角碰撞
        return map.tileIndexToWorld(tileIndex - 1).addX(offsetX);
    }
    return new;
}

fn clampUp(new: Vector2, size: Vector2) Vector2 {
    const sz = size.add(epsilon);

    var tileIndex = map.worldToTileIndex(new);
    if (tileStates[tileIndex] == .solid) { // 左上角碰撞
        return map.tileIndexToWorld(tileIndex + map.width);
    }
    tileIndex = map.worldToTileIndex(new.addX(sz.x));
    if (tileStates[tileIndex] == .solid) { // 右上角碰撞
        return map.tileIndexToWorld(tileIndex + map.width);
    }
    return new;
}

fn clampDown(new: Vector2, size: Vector2) Vector2 {
    const sz = size.add(epsilon);

    var tileIndex = map.worldToTileIndex(new.addY(sz.y)); // 左下角
    const offset = map.tileSize.y - size.y;
    var tileEnum = tileStates[tileIndex];
    if (tileEnum == .solid or tileEnum == .uniSolid) {
        return map.tileIndexToWorld(tileIndex - map.width).addY(offset);
    }

    tileIndex = map.worldToTileIndex(new.add(sz)); // 右下角
    tileEnum = tileStates[tileIndex];
    if (tileEnum == .solid or tileEnum == .uniSolid) {
        return map.tileIndexToWorld(tileIndex - map.width).addY(offset);
    }

    return new;
}

pub fn draw() void {
    for (map.layers) |*layer| {
        if (layer.type == .image) drawImageLayer(layer);
    }

    batch.vertexBuffer.appendSliceAssumeCapacity(tileVertexes.items);
}

fn drawImageLayer(layer: *const tiled.Layer) void {
    batch.camera.modeEnum = .window;
    defer batch.camera.modeEnum = .world;

    if (layer.repeatY) {
        const posY = batch.camera.position.y * layer.parallaxY;
        var y = -@mod(posY, layer.height);
        while (y < window.size.y) : (y += layer.height) {
            batch.draw(layer.image, layer.offset.addXY(0, y));
        }
    }

    if (layer.repeatX) {
        const posX = batch.camera.position.x * layer.parallaxX;
        var x = -@mod(posX, layer.width);
        while (x < window.size.x) : (x += layer.width) {
            batch.draw(layer.image, layer.offset.addXY(x, 0));
        }
    }
}
```

## 效果

![进入下一关][1]

[1]: images/阳光岛31.gif

## 附录
