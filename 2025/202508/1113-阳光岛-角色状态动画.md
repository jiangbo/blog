# 1113-阳光岛-角色状态动画

## 目标

给角色的四个状态添加了动画。

## 环境

- Time 2026-01-24
- Zig 0.15.1

## 参考

1. <https://www.bilibili.com/video/BV1jf9XYQEhW>

## 想法

角色单独处理的动画，其它物品和对象的动画怎么处理呢？教程中是写到 tiled 中处理的。

## player.zig

为四个状态添加了动画。

```zig
const std = @import("std");
const zhu = @import("zhu");

const batch = zhu.batch;
const tiled = zhu.extend.tiled;

const map = @import("map.zig");

const moveForce = 200; // 移动力
const factor = 0.85; // 减速因子
const maxSpeed = 120; // 最大速度
const gravity = 980; // 重力
const jumpForce = 350.0; // 跳跃力

const size: zhu.Vector2 = .xy(32, 32);
var image: zhu.graphics.Image = undefined;

var force: zhu.Vector2 = .xy(0, gravity);
var velocity: zhu.Vector2 = .zero;
pub var position: zhu.Vector2 = undefined;
var state: State = .idle;

pub fn init(pos: zhu.Vector2) void {
    position = pos;
    const foxy = zhu.getImage("textures/Actors/foxy.png");

    image = foxy.sub(.init(.zero, size));
    inline for (std.meta.fields(State)) |field| field.type.init();

    state.enter();
}

pub fn update(delta: f32) void {
    state.update(delta);

    velocity = velocity.add(force.scale(delta));
    velocity.x = std.math.clamp(velocity.x, -maxSpeed, maxSpeed);
    const toPosition = position.add(velocity.scale(delta));

    const clamped = map.clamp(position, toPosition, size);
    // std.log.info("old: {}, new: {}, clamped: {}", .{ position, toPosition, clamped });
    if (clamped.x == position.x) velocity.x = 0;
    if (clamped.y == position.y) velocity.y = 0;
    position = clamped;
}

pub fn draw() void {
    state.draw();
}

const State = union(enum) {
    idle: IdleState,
    walk: WalkState,
    jump: JumpState,
    fall: FallState,

    fn enter(self: State) void {
        switch (self) {
            inline else => |case| @TypeOf(case).enter(),
        }
    }

    fn update(self: State, delta: f32) void {
        switch (self) {
            inline else => |case| @TypeOf(case).update(delta),
        }
    }

    fn draw(self: State) void {
        switch (self) {
            inline else => |case| @TypeOf(case).draw(),
        }
    }
};

fn changeState(newState: State) void {
    state = newState;
    state.enter();
}

const IdleState = struct {
    var animation: zhu.graphics.FrameAnimation = undefined;
    const frames = zhu.graphics.loopFramesX(4, size, 0.2);

    pub fn init() void {
        const idleImage = image.sub(.init(.zero, .xy(32, 128)));
        animation = .init(idleImage, &frames);
    }

    fn enter() void {
        std.log.info("enter idle", .{});
    }

    fn update(delta: f32) void {
        animation.loopUpdate(delta);
        if (zhu.window.isAnyKeyPress(&.{ .W, .SPACE })) {
            changeState(.jump);
        } else if (zhu.window.isAnyKeyDown(&.{ .A, .D })) {
            changeState(.walk);
        } else velocity.x *= factor; // 减速
    }

    fn draw() void {
        batch.drawImage(animation.currentImage(), position, .{
            .flipX = velocity.x < 0,
        });
    }
};

const WalkState = struct {
    var animation: zhu.graphics.FrameAnimation = undefined;
    const frames = zhu.graphics.loopFramesX(6, size, 0.1);

    pub fn init() void {
        const walkImage = image.sub(.init(.xy(0, 32), .xy(32, 198)));
        animation = .init(walkImage, &frames);
    }

    fn enter() void {
        std.log.info("enter walk", .{});
    }

    fn update(delta: f32) void {
        animation.loopUpdate(delta);

        if (zhu.window.isAnyKeyPress(&.{ .W, .SPACE })) {
            changeState(.jump);
        } else if (zhu.window.isKeyDown(.A)) {
            if (velocity.x > 0) velocity.x = 0;
            force.x = -moveForce;
        } else if (zhu.window.isKeyDown(.D)) {
            if (velocity.x < 0) velocity.x = 0;
            force.x = moveForce;
        } else {
            force.x = 0;
            changeState(.idle);
        }
    }

    fn draw() void {
        batch.drawImage(animation.currentImage(), position, .{
            .flipX = velocity.x < 0,
        });
    }
};
const JumpState = struct {
    var jumpImage: zhu.graphics.Image = undefined;

    pub fn init() void {
        jumpImage = image.sub(.init(.xy(0, 160), size));
    }

    fn enter() void {
        std.log.info("enter jump", .{});
        velocity.y = -jumpForce;
    }

    fn update(_: f32) void {
        if (velocity.y > 0) {
            changeState(.fall);
        }
    }

    fn draw() void {
        batch.drawImage(jumpImage, position, .{
            .flipX = velocity.x < 0,
        });
    }
};
const FallState = struct {
    var fallImage: zhu.graphics.Image = undefined;

    pub fn init() void {
        fallImage = image.sub(.init(.xy(32, 160), size));
    }

    fn enter() void {
        std.log.info("enter fall", .{});
    }

    fn update(_: f32) void {
        if (velocity.y == 0) {
            changeState(.idle);
        }
    }

    fn draw() void {
        batch.drawImage(fallImage, position, .{
            .flipX = velocity.x < 0,
        });
    }
};
```

## 效果

![角色状态动画][1]

[1]: images/阳光岛11.gif

## 附录
