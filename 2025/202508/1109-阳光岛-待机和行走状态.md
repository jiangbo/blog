# 1109-阳光岛-待机和行走状态

## 目标

新增行走状态，然后可以在待机和行走状态之间进行切换。

## 环境

- Time 2026-01-23
- Zig 0.15.1

## 参考

1. <https://www.bilibili.com/video/BV1jf9XYQEhW>

## 想法

想了一下，暂时还是不引入物理引擎模块了，把这个教程做完对比一下，再看看。

## player.zig

状态之间可以进行切换。

```zig
const std = @import("std");
const zhu = @import("zhu");

const moveForce = 200; // 移动力
const factor = 0.85; // 减速因子
const maxSpeed = 120; // 最大速度

const size: zhu.Vector2 = .xy(32, 32);
var image: zhu.graphics.Image = undefined;

var velocity: zhu.Vector2 = .zero;
var position: zhu.Vector2 = undefined;
var state: State = .idle;

pub fn init(pos: zhu.Vector2) void {
    position = pos;
    const foxy = zhu.getImage("textures/Actors/foxy.png");
    image = foxy.sub(.init(.zero, size));
    state.enter();
}

pub fn update(delta: f32) void {
    state.update(delta);
}

pub fn draw() void {
    zhu.batch.drawImage(image, position, .{
        .flipX = velocity.x < 0,
    });
}

const State = union(enum) {
    idle: IdleState,
    walk: WalkState,
    // jump: JumpState,
    // fall: FallState,

    fn enter(self: State) void {
        switch (self) {
            inline else => |case| @TypeOf(case).enter(),
        }
    }

    fn update(self: State, delta: f32) void {
        switch (self) {
            inline else => |case| @TypeOf(case).update(delta),
        }
    }

    fn draw(self: State) void {
        switch (self) {
            inline else => |case| @TypeOf(case).draw(),
        }
    }
};

fn changeState(newState: State) void {
    state = newState;
    state.enter();
}

const IdleState = struct {
    fn enter() void {
        std.log.info("enter idle", .{});
    }

    fn update(delta: f32) void {
        if (zhu.window.isAnyKeyDown(&.{ .A, .D })) {
            changeState(.walk);
        } else {
            velocity.x *= factor;
            position = position.add(velocity.scale(delta));
        }
    }
};

const WalkState = struct {
    fn enter() void {
        std.log.info("enter walk", .{});
    }

    fn update(delta: f32) void {
        if (zhu.window.isKeyDown(.A)) {
            if (velocity.x > 0) velocity.x = 0;
            velocity.x -= moveForce * delta;
        } else if (zhu.window.isKeyDown(.D)) {
            if (velocity.x < 0) velocity.x = 0;
            velocity.x += moveForce * delta;
        } else {
            return changeState(.idle);
        }

        velocity.x = std.math.clamp(velocity.x, -maxSpeed, maxSpeed);
        position = position.add(velocity.scale(delta));
    }
};
const JumpState = struct {};
const FallState = struct {};
```

## 效果

没有改变任何逻辑，效果和之前一样。

![待机和行走状态][1]

[1]: images/阳光岛07.gif

## 附录
