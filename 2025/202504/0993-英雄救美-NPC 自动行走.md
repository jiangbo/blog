# 0993-英雄救美-NPC 自动行走

## 目标

NPC 可以自主在地图上行走，并且避开地图的障碍和角色。

## 环境

- Time 2025-08-16
- Zig 0.14.1

## 参考

1. 圣剑英雄传：英雄救美源码。

## 想法

使用定时器控制 NPC，一定时间后调整到随机方向，然后继续行走。

## player.zon

```zig
const std = @import("std");

const zhu = @import("zhu");
const window = zhu.window;
const gfx = zhu.gfx;
const camera = zhu.camera;
const math = zhu.math;

const scene = @import("scene.zig");
const item = @import("item.zig");
const map = @import("map.zig");
const npc = @import("npc.zig");

const Animation = std.EnumArray(math.FourDirection, gfx.FrameAnimation);

const name = "小飞刀";
const MOVE_SPEED = 100;
const SIZE: math.Vector = .init(16, 16);
var texture: gfx.Texture = undefined;
var animation: Animation = undefined;

var facings: std.EnumArray(math.FourDirection, u64) = undefined;
pub var facing: math.FourDirection = .down;
pub var position: math.Vector = undefined;

pub var money: usize = 50; // 金钱
pub var items: [16]u16 = undefined;
var itemIndex: usize = 0;

var level: usize = 1; //等级
var exp: usize = 0; //经验
var maxExp: usize = 100; //经验最大值
var health: usize = 50; //生命
var maxHealth: usize = 50; //生命最大值
var attack: usize = 10; //攻击
var defend: usize = 10; //防御
var speed: usize = 8; //速度

var bgTexture: gfx.Texture = undefined;
var itemTexture: gfx.Texture = undefined;
const frames: [3]gfx.Frame = .{
    .{ .area = .init(.init(0, 0), .init(32, 48)), .interval = 0.15 },
    .{ .area = .init(.init(32, 0), .init(32, 48)), .interval = 0.15 },
    .{ .area = .init(.init(64, 0), .init(32, 48)), .interval = 0.15 },
};

pub fn init() void {
    texture = gfx.loadTexture("assets/pic/player.png", .init(96, 192));
    bgTexture = gfx.loadTexture("assets/pic/sbar.png", .init(420, 320));
    itemTexture = gfx.loadTexture("assets/pic/goods.png", .init(384, 192));

    animation = Animation.initUndefined();

    var tex = texture.subTexture(.init(.zero, .init(96, 48)));
    animation.set(.down, gfx.FrameAnimation.init(tex, &frames));

    tex = texture.subTexture(tex.area.move(.init(0, 48)));
    animation.set(.left, gfx.FrameAnimation.init(tex, &frames));

    tex = texture.subTexture(tex.area.move(.init(0, 48)));
    animation.set(.right, gfx.FrameAnimation.init(tex, &frames));

    tex = texture.subTexture(tex.area.move(.init(0, 48)));
    animation.set(.up, gfx.FrameAnimation.init(tex, &frames));

    @memset(&items, 0);
}

pub fn enter(playerPosition: math.Vector2) void {
    position = playerPosition;
    cameraLookAt();
}

pub fn exit() void {}

pub fn update(delta: f32) void {

    // 角色移动和碰撞检测
    const dir = updateFacing();
    if (dir.x == 0 and dir.y == 0) return; // 没有移动
    animation.getPtr(facing).update(delta);

    const velocity = dir.normalize().scale(MOVE_SPEED).scale(delta);

    const area = math.Rectangle.init(position, SIZE);
    if (npc.isCollision(area.move(velocity))) return;

    position = map.walkTo(area, velocity);
    // 相机跟踪
    cameraLookAt();

    // 检测是否需要切换场景
    const object = map.getObject(map.positionIndex(area.center()));
    if (object > 4) {
        std.log.info("change scene id: {d}", .{object});
        map.linkIndex = object;
        scene.changeScene(.world);
    }
}

fn updateFacing() math.Vector2 {
    const count = window.frameCount();
    var dir = math.Vector.zero;

    if (window.isAnyKeyDown(&.{ .UP, .W })) {
        dir.y -= 1;
        if (facings.get(.up) == 0) facings.set(.up, count);
    } else facings.set(.up, 0);

    if (window.isAnyKeyDown(&.{ .DOWN, .S })) {
        dir.y += 1;
        if (facings.get(.down) == 0) facings.set(.down, count);
    } else facings.set(.down, 0);

    if (window.isAnyKeyDown(&.{ .LEFT, .A })) {
        dir.x -= 1;
        if (facings.get(.left) == 0) facings.set(.left, count);
    } else facings.set(.left, 0);

    if (window.isAnyKeyDown(&.{ .RIGHT, .D })) {
        dir.x += 1;
        if (facings.get(.right) == 0) facings.set(.right, count);
    } else facings.set(.right, 0);

    var max: u64 = 0;
    var iterator = facings.iterator();
    while (iterator.next()) |entry| {
        if (entry.value.* > max) {
            max = entry.value.*;
            facing = entry.key;
        }
    }
    return dir;
}

fn cameraLookAt() void {
    const half = window.logicSize.scale(0.5);
    const max = map.size.sub(window.logicSize);
    camera.position = position.sub(half).clamp(.zero, max);
}

pub fn updateItem() void {
    if (window.isAnyKeyRelease(&.{ .LEFT, .A })) {
        itemIndex -|= 1;
    }

    if (window.isAnyKeyRelease(&.{ .RIGHT, .D })) {
        itemIndex += 1;
        if (itemIndex >= items.len) itemIndex = items.len - 1;
    }

    if (window.isAnyKeyRelease(&.{ .DOWN, .S })) {
        itemIndex = (itemIndex + items.len / 2) % items.len;
    }

    if (window.isAnyKeyRelease(&.{ .UP, .W })) {
        itemIndex = (itemIndex + items.len / 2 * 3) % items.len;
    }
}

pub fn collider() math.Rectangle {
    return math.Rectangle.init(position, SIZE);
}

pub fn addItem(itemId: u16) void {
    for (&items) |*value| {
        if (value.* == 0) {
            value.* = itemId;
            return;
        }
    }
}

pub fn draw() void {
    const current = animation.get(facing);
    camera.draw(current.currentTexture(), position.addXY(-10, -28));

    camera.debugDraw(.init(position, SIZE));
}

pub fn drawTalk() void {

    // 头像
    const down = animation.get(.down);
    const tex = down.texture.subTexture(down.frames[0].area);
    camera.draw(tex, .init(30, 396));

    // 名字
    const nameColor = gfx.color(1, 1, 0, 1);
    camera.drawColorText(name, .init(18, 445), nameColor);
}

pub fn drawStatus() void {
    const pos = gfx.Vector.init(120, 90);
    // 背景
    camera.draw(bgTexture, pos.addXY(-10, -10));

    // 头像
    const down = animation.get(.down);
    const tex = down.texture.subTexture(down.frames[0].area);
    camera.draw(tex, pos.addXY(10, 10));

    // 等级
    camera.drawColorText("等级：", pos.addXY(122, 52), .{ .w = 1 });
    camera.drawText("等级：", pos.addXY(120, 50));
    camera.drawColorNumber(level, pos.addXY(232, 52), .{ .w = 1 });
    camera.drawNumber(level, pos.addXY(230, 50));

    // 经验
    camera.drawColorText("经验：", pos.addXY(122, 82), .{ .w = 1 });
    camera.drawText("经验：", pos.addXY(120, 80));
    var buffer: [30]u8 = undefined;
    const expStr = zhu.format(&buffer, "{d}/{d}", .{ exp, maxExp });
    camera.drawColorText(expStr, pos.addXY(232, 82), .{ .w = 1 });
    camera.drawText(expStr, pos.addXY(230, 80));

    // 生命
    camera.drawColorText("生命：", pos.addXY(122, 112), .{ .w = 1 });
    camera.drawText("生命：", pos.addXY(120, 110));
    const healthStr = zhu.format(&buffer, "{d}/{d}", .{ health, maxHealth });
    camera.drawColorText(healthStr, pos.addXY(232, 112), .{ .w = 1 });
    camera.drawText(healthStr, pos.addXY(230, 110));

    // 攻击
    camera.drawColorText("攻击：", pos.addXY(122, 142), .{ .w = 1 });
    camera.drawText("攻击：", pos.addXY(120, 140));
    camera.drawColorNumber(attack, pos.addXY(232, 142), .{ .w = 1 });
    camera.drawNumber(attack, pos.addXY(230, 140));

    // 防御
    camera.drawColorText("防御：", pos.addXY(122, 172), .{ .w = 1 });
    camera.drawText("防御：", pos.addXY(120, 170));
    camera.drawColorNumber(defend, pos.addXY(232, 172), .{ .w = 1 });
    camera.drawNumber(defend, pos.addXY(230, 170));

    // 速度
    camera.drawColorText("速度：", pos.addXY(122, 202), .{ .w = 1 });
    camera.drawText("速度：", pos.addXY(120, 200));
    camera.drawColorNumber(speed, pos.addXY(232, 202), .{ .w = 1 });
    camera.drawNumber(speed, pos.addXY(230, 200));

    // 金币
    camera.drawColorText("金币：", pos.addXY(122, 232), .{ .w = 1 });
    camera.drawColorText("金币：", pos.addXY(120, 230), gfx.color(1, 1, 0, 1));
    camera.drawColorNumber(money, pos.addXY(232, 230), .{ .w = 1 });
    camera.drawColorNumber(money, pos.addXY(230, 230), gfx.color(1, 1, 0, 1));
}

pub fn drawItem() void {
    const pos = gfx.Vector.init(120, 90);
    camera.draw(bgTexture, pos.addXY(-10, -10));

    // 当前选中物品
    var buffer: [32]u8 = undefined;
    if (items[itemIndex] != 0) {
        const current = item.zon[items[itemIndex]];

        camera.drawText(current.name, pos.addXY(70, 20));
        camera.drawText(" (价值：", pos.addXY(180, 20));
        const text = zhu.format(&buffer, "{d}）", .{current.money});
        camera.drawText(text, pos.addXY(260, 20));

        camera.drawText("经验：", pos.addXY(20, 60));
        camera.drawNumber(current.exp, pos.addXY(100, 60));

        camera.drawText("生命：", pos.addXY(20, 86));
        camera.drawNumber(current.health, pos.addXY(100, 86));

        camera.drawText("攻击：", pos.addXY(20, 112));
        camera.drawNumber(current.attack, pos.addXY(100, 112));

        camera.drawText("防御：", pos.addXY(20, 134));
        camera.drawNumber(current.defend, pos.addXY(100, 134));

        // 描述
        const color = gfx.color(1, 1, 0, 1);
        camera.drawColorText(current.about, pos.addXY(170, 60), color);
    }

    const itemBg = getItemIconFromIndex(0);
    const itemSelected = getItemIconFromIndex(1);

    const offset = pos.addXY(5, 170);

    for (0..2) |i| {
        const row: f32 = @floatFromInt(i);
        for (0..8) |j| {
            const col: f32 = @floatFromInt(j);
            const itemPos = offset.addXY(col * 49, row * 49);
            camera.draw(itemBg, itemPos);

            const index = j + 8 * i;
            defer if (itemIndex == index) camera.draw(itemSelected, itemPos);
            if (items[index] == 0) continue;

            camera.draw(getItemIconFromIndex(items[index] - 2), itemPos);
        }
    }
    // 金币，操作说明
    camera.drawText("（金=", pos.addXY(10, 270));
    const moneyStr = zhu.format(&buffer, "{d}）", .{money});
    camera.drawText(moneyStr, pos.addXY(60, 270));
    camera.drawText("CTRL=使用‘A’=丢弃 ESC=退出", pos.addXY(118, 270));
}

fn getItemIconFromIndex(index: usize) gfx.Texture {
    const row: f32 = @floatFromInt(index / 8);
    const col: f32 = @floatFromInt(index % 8);
    const pos = gfx.Vector.init(col * 48, row * 48);
    return itemTexture.subTexture(.init(pos, .init(48, 48)));
}
```

## npc.zig

```zig
const std = @import("std");
const zhu = @import("zhu");

const window = zhu.window;
const gfx = zhu.gfx;
const camera = zhu.camera;
const math = zhu.math;

const SIZE: math.Vector2 = .init(32, 32);
const map = @import("map.zig");
const player = @import("player.zig");

const Animation = std.EnumArray(math.FourDirection, gfx.FrameAnimation);
const zon: []const Character = @import("zon/npc.zon");
const imageNames: []const [:0]const u8 = @import("zon/npcTex.zon");
var npcTextures: [imageNames.len]gfx.Texture = undefined;
const frames: [2]gfx.Frame = .{
    .{ .area = .init(.init(0, 0), .init(32, 32)), .interval = 0.5 },
    .{ .area = .init(.init(32, 0), .init(32, 32)), .interval = 0.5 },
};

const Info = struct {
    index: u8,
    position: math.Vector2,
    facing: gfx.FourDirection = .down,
    animation: Animation,
    timer: window.Timer = .init(5),
};

var buffer: [10]Info = undefined;
var npcArray: std.ArrayListUnmanaged(Info) = undefined;

pub fn init() void {
    for (imageNames, &npcTextures) |name, *texture| {
        texture.* = gfx.loadTexture(name, .init(64, 128));
    }
    npcArray = .initBuffer(&buffer);
}

pub fn enter() void {
    npcArray.clearRetainingCapacity();

    for (map.current.npcs) |id| {
        npcArray.appendAssumeCapacity(.{
            .index = id,
            .position = .init(zon[id].x, zon[id].y),
            .animation = buildAnimation(npcTextures[id]),
        });
    }
}

fn buildAnimation(texture: gfx.Texture) Animation {
    var animation = Animation.initUndefined();

    var tex = texture.subTexture(.init(.zero, .init(64, SIZE.x)));
    animation.set(.down, gfx.FrameAnimation.init(tex, &frames));
    tex = texture.subTexture(tex.area.move(.init(0, SIZE.x)));
    animation.set(.left, gfx.FrameAnimation.init(tex, &frames));
    tex = texture.subTexture(tex.area.move(.init(0, SIZE.x)));
    animation.set(.up, gfx.FrameAnimation.init(tex, &frames));
    tex = texture.subTexture(tex.area.move(.init(0, SIZE.x)));
    animation.set(.right, gfx.FrameAnimation.init(tex, &frames));

    return animation;
}

pub fn update(delta: f32) void {
    for (npcArray.items) |*npc| {
        if (npc.timer.isFinishedAfterUpdate(delta)) {
            npc.facing = .random();
            npc.timer.reset();
        }

        npc.animation.getPtr(npc.facing).update(delta);
        const distance = zon[npc.index].speed * delta;
        var newPosition = npc.position;
        switch (npc.facing) {
            .down => newPosition.y += distance,
            .left => newPosition.x -= distance,
            .right => newPosition.x += distance,
            .up => newPosition.y -= distance,
        }

        const max = newPosition.add(SIZE);
        if (map.canWalk(newPosition) and map.canWalk(max)) {
            // 检测和角色的碰撞
            const collider = math.Rectangle.init(newPosition, SIZE);
            if (!collider.intersect(player.collider())) {
                npc.position = newPosition;
            }
        } else {
            const old = npc.facing;
            while (old == npc.facing) npc.facing = .random();
            npc.timer.reset();
        }
    }
}

pub fn isCollision(collider: math.Rectangle) bool {
    for (npcArray.items) |npc| {
        const npcCollider = math.Rectangle.init(npc.position, SIZE);
        if (collider.intersect(npcCollider)) return true;
    }
    return false;
}

pub fn draw() void {
    for (npcArray.items) |npc| {
        const animation = npc.animation.getPtrConst(npc.facing);
        camera.draw(animation.currentTexture(), npc.position);
    }
}

pub const Character = struct {
    id: u32,
    pic: u8,
    enemy: bool,
    talkNum: u8,
    active: bool,
    show: bool,
    name: []const u8,
    width: u16,
    height: u16,
    x: f32,
    y: f32,
    oldX: u16,
    oldY: u16,
    facing: gfx.FourDirection = .down,
    stats: u8,
    level: u8,
    exp: u32,
    lift: u16,
    maxLift: u16,
    attack: u16,
    defend: u16,
    speed: f32,
    goods: [1]u32,
    money: u32,
};
```

## 效果

![NPC 自动行走][1]

[1]: images/英雄救美24.png

## 附录
