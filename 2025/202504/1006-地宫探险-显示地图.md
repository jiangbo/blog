# 1006-地宫探险-显示地图

## 目标

新建地图模块，随便生成地图上的房间，然后显示出来。

## 环境

- Time 2025-10-23
- Zig 0.15.2

## 参考

1. <https://pragprog.com/titles/hwrust/hands-on-rust/>
2. 《Rust游戏开发实战》

## 想法

窗口大小缩小了两倍，地图现在缩小了五倍，所以可以看到全地图，增加控制相机移动的功能。

## scene.zig

场景模块，从上个项目复制过来的，主要新增了一个控制相机的功能。

```zig
const std = @import("std");
const zhu = @import("zhu");

const window = zhu.window;
const gfx = zhu.gfx;
const camera = zhu.camera;

const map = @import("map.zig");

var isHelp: bool = false;
var isDebug: bool = true;

pub fn init() void {
    window.initFont(.{
        .font = @import("zon/font.zon"),
        .texture = gfx.loadTexture("assets/font.png", .init(960, 960)),
    });

    camera.frameStats(true);
    camera.init(5000);

    map.init();

    sceneCall("enter", .{});
}

const SPEED = 100;
pub fn update(delta: f32) void {
    window.keepAspectRatio();
    if (window.isKeyRelease(.H)) isHelp = !isHelp;
    if (window.isKeyRelease(.X)) isDebug = !isDebug;

    if (window.isKeyDown(.LEFT_ALT) and window.isKeyRelease(.ENTER)) {
        return window.toggleFullScreen();
    }

    const speed: f32 = std.math.round(SPEED * delta);
    if (window.isKeyDown(.W)) camera.position.y -= 1 * speed;
    if (window.isKeyDown(.S)) camera.position.y += 1 * speed;
    if (window.isKeyDown(.A)) camera.position.x -= 1 * speed;
    if (window.isKeyDown(.D)) camera.position.x += 1 * speed;

    sceneCall("update", .{delta});
}

pub fn draw() void {
    camera.beginDraw();
    defer camera.endDraw();

    sceneCall("draw", .{});
    map.draw();
    if (isHelp) drawHelpInfo() else if (isDebug) drawDebugInfo();
}

fn drawHelpInfo() void {
    const text =
        \\按键说明：
        \\上：W，下：S，左：A，右：D
        \\确定：F，取消：Q，菜单：E
        \\帮助：H  按一次打开，再按一次关掉
    ;
    var iterator = std.unicode.Utf8View.initUnchecked(text).iterator();
    var count: u32 = 0;
    while (iterator.nextCodepoint()) |code| {
        if (code == '\n') continue;
        count += 1;
    }
    debutTextCount = count;

    camera.drawColorText(text, .init(10, 5), .green);
}

var debutTextCount: u32 = 0;
fn drawDebugInfo() void {
    var buffer: [1024]u8 = undefined;
    const format =
        \\后端：{s}
        \\帧率：{}
        \\帧时：{d:.2}
        \\用时：{d:.2}
        \\显存：{}
        \\常量：{}
        \\绘制：{}
        \\图片：{}
        \\文字：{}
        \\内存：{}
        \\鼠标：{d:.2}，{d:.2}
        \\相机：{d:.2}，{d:.2}
    ;

    const stats = camera.queryFrameStats();
    const text = zhu.format(&buffer, format, .{
        @tagName(camera.queryBackend()),
        window.frameRate,
        window.frameDeltaPerSecond,
        window.usedDeltaPerSecond,
        stats.size_append_buffer + stats.size_update_buffer,
        stats.size_apply_uniforms,
        stats.num_draw,
        camera.imageDrawCount(),
        // Debug 信息本身的次数也应该统计进去
        camera.textDrawCount() + debutTextCount,
        window.countingAllocator.used,
        window.mousePosition.x,
        window.mousePosition.y,
        camera.position.x,
        camera.position.y,
    });

    var iterator = std.unicode.Utf8View.initUnchecked(text).iterator();
    var count: u32 = 0;
    while (iterator.nextCodepoint()) |code| {
        if (code == '\n') continue;
        count += 1;
    }
    debutTextCount = count;

    camera.drawColorText(text, .init(10, 5), .green);
}

pub fn deinit() void {
    sceneCall("deinit", .{});
}

fn sceneCall(comptime function: []const u8, args: anytype) void {
    _ = function;
    _ = args;
}
```

## map.zig

地图模块，参考了上个项目的渲染 tile 的功能。

```zig
const std = @import("std");
const zhu = @import("zhu");

const gfx = zhu.gfx;
const camera = zhu.camera;

const Tile = enum(u8) {
    other = 0,
    wall = 35,
    floor = 46,
    player = 64,
    ettin = 69,
    ogre = 79,
    goblin = 103,
    orc = 111,
    amulet = 124,
};

const Rect = struct { x: u8, y: u8, w: u8, h: u8 };
const Vec = struct { x: u8, y: u8 };

const WIDTH = 80;
const HEIGHT = 50;
const NUM_ROOMS = 20;
const TILE_SIZE: gfx.Vector = .init(32, 32);
const TILE_PER_ROW = 16;
const SCALE = 0.2;

var tiles: [WIDTH * HEIGHT]Tile = undefined;
var vertexBuffer: [tiles.len]camera.Vertex = undefined;
var texture: gfx.Texture = undefined;
var rooms: [NUM_ROOMS]Rect = undefined;

pub fn init() void {
    texture = gfx.loadTexture("assets/dungeonfont.png", .init(512, 512));

    @memset(&tiles, .wall);
    buildRooms();
    std.mem.sort(Rect, &rooms, {}, compare);
    buildCorridors();

    initVertexBuffer();
}

fn initVertexBuffer() void {
    var array: std.ArrayList(camera.Vertex) = .initBuffer(&vertexBuffer);
    for (tiles, 0..) |tileIndex, index| {
        const tile: u8 = @intFromEnum(tileIndex);
        array.appendAssumeCapacity(buildVertex(tile, index));
    }
}

fn buildVertex(tileIndex: usize, index: usize) camera.Vertex {
    const row: f32 = @floatFromInt(tileIndex / TILE_PER_ROW);
    const col: f32 = @floatFromInt(tileIndex % TILE_PER_ROW);

    const pos = gfx.Vector.init(col, row).mul(TILE_SIZE);

    const tile = texture.subTexture(.init(pos, TILE_SIZE));
    return camera.Vertex{
        .position = getPositionFromIndex(index).toVector3(0),
        .size = TILE_SIZE.scale(SCALE),
        .texture = tile.area.toVector4(),
    };
}

fn getPositionFromIndex(index: usize) gfx.Vector {
    const row: f32 = @floatFromInt(index / WIDTH);
    const col: f32 = @floatFromInt(index % WIDTH);
    return gfx.Vector.init(col, row).mul(TILE_SIZE.scale(SCALE));
}

fn buildRooms() void {
    for (0..rooms.len) |roomIndex| {
        var room: Rect = undefined;
        label: {
            room = Rect{
                .x = zhu.randU8(1, WIDTH - 10),
                .y = zhu.randU8(1, HEIGHT - 10),
                .w = zhu.randU8(2, 10),
                .h = zhu.randU8(2, 10),
            };

            for (0..roomIndex) |idx| {
                if (intersect(rooms[idx], room)) break :label;
            }
        }

        for (room.y..room.y + room.h) |y| {
            for (room.x..room.x + room.w) |x| {
                setTile(x, y, .floor);
            }
        }
        rooms[roomIndex] = room;
    }
}

fn intersect(r1: Rect, r2: Rect) bool {
    return r1.x < r2.x + r2.w and r1.x + r1.w > r2.x and
        r1.y < r2.y + r2.h and r1.y + r1.h > r2.y;
}

fn center(r: Rect) Vec {
    return Vec{ .x = r.x + r.w / 2, .y = r.y + r.h / 2 };
}

fn compare(_: void, r1: Rect, r2: Rect) bool {
    return if (r1.x == r2.x) r1.y < r2.y else r1.x < r2.x;
}

fn applyVertical(y1: usize, y2: usize, x: usize) void {
    for (@min(y1, y2)..@max(y1, y2) + 1) |y| {
        setTile(x, y, .floor);
    }
}

fn applyHorizontal(x1: usize, x2: usize, y: usize) void {
    for (@min(x1, x2)..@max(x1, x2) + 1) |x| {
        setTile(x, y, .floor);
    }
}

fn buildCorridors() void {
    for (rooms[1..], 1..) |room, roomIndex| {
        const prev = center(rooms[roomIndex - 1]);
        const new = center(room);
        if (zhu.randU8(0, 2) == 1) {
            applyHorizontal(prev.x, new.x, prev.y);
            applyVertical(prev.y, new.y, new.x);
        } else {
            applyVertical(prev.y, new.y, prev.x);
            applyHorizontal(prev.x, new.x, new.y);
        }
    }
}

fn indexUsize(x: usize, y: usize) usize {
    const x1 = if (x < WIDTH) x else WIDTH - 1;
    const y1 = if (y < HEIGHT) y else HEIGHT - 1;
    return x1 + y1 * WIDTH;
}

pub fn setTile(x: usize, y: usize, tile: Tile) void {
    tiles[indexUsize(x, y)] = tile;
}

pub fn indexTile(x: usize, y: usize) Tile {
    return tiles[indexUsize(x, y)];
}

pub fn canEnter(player: zhu.math.Vector2) bool {
    return player.x < WIDTH and player.y < HEIGHT //
    and indexTile(player.x, player.y) == .floor;
}

pub fn draw() void {
    camera.drawVertices(texture, &vertexBuffer);
}
```

## 效果

![显示地图][1]

[1]: images/地宫探险02.png

## 附录
