# 1095-幽灵逃生-暂停重启返回

## 目标

在场景中新增三个按钮，实现暂停、重启和返回功能。

## 环境

- Time 2026-01-14
- Zig 0.15.1

## 参考

1. <https://www.bilibili.com/video/BV1jf9XYQEhW>

## 想法

感觉随着代码量增加，管理场景的复杂度也在提升，现在代码有点乱。

## battle.zig

把暂停、重启和返回功能放在了战斗模块中实现。

```zig
const std = @import("std");
const zhu = @import("zhu");

const camera = zhu.camera;

const scene = @import("scene.zig");
const world = @import("world.zig");
const player = @import("player.zig");
const enemy = @import("enemy.zig");

pub const Stats = struct {
    health: u32 = 100, // 生命值
    maxHealth: u32 = 100, // 最大生命值
    attack: u32 = 40, // 攻击力
};

const circle = zhu.graphics.imageId("circle.png"); // 显示碰撞范围
const spellFrames = zhu.graphics.framesX(13, .xy(64, 64), 0.1);
const spellDamageIndex = 6; // 动画第 6 帧造成伤害，视觉效果好一点
const spellSize = spellFrames[0].area.size.scale(3);

var spellTimer: zhu.window.Timer = .init(2);
var spellAnimations: [4]zhu.graphics.FrameAnimation = undefined;
var spellPositions: [4]zhu.Vector2 = undefined;
var mana: u32 = 100;
var manaTimer: zhu.window.Timer = .init(1); // 每秒回复一次魔法值

var score: u32 = 0;

pub fn init() void {
    const image = zhu.graphics.getImage("effect/Thunderstrike w blur.png");
    for (&spellAnimations) |*a| a.* = .initFinished(image, &spellFrames);
    spellTimer.stop(); // 一开始就可以直接使用魔法
}

pub fn enter() void {
    mana = 100;
    spellTimer.stop();
    score = 0;
    world.isPause = false;
}

pub fn update(delta: f32) void {
    const press = updateButton();
    if (world.isPause) return;

    spellTimer.update(delta);
    if (manaTimer.isFinishedLoopUpdate(delta)) {
        mana += 10;
        if (mana > 100) mana = 100;
    }

    // 角色使用魔法
    const canCastSpell = !press and zhu.window.isMouseRelease(.LEFT);
    if (canCastSpell and player.stats.health > 0) {
        playerCastSpell(camera.toWorld(zhu.window.mousePosition));
    }

    for (&spellPositions, &spellAnimations) |pos, *ani| {
        if (ani.isFinished()) continue;

        const changed = ani.isNextOnceUpdate(delta);
        if (changed and ani.index == spellDamageIndex) {
            var iterator = std.mem.reverseIterator(enemy.enemies.items);
            while (iterator.nextPtr()) |e| {
                const len = (spellSize.x + enemy.size.x) * 0.5;
                const len2 = pos.sub(e.position).length2();
                if (len2 < len * len) e.stats.health -|= player.stats.attack;
                if (e.stats.health == 0) {
                    _ = enemy.enemies.swapRemove(iterator.index);
                    score += 1;
                }
            }
        }
    }
}

fn playerCastSpell(position: zhu.Vector2) void {
    if (mana < 30 or spellTimer.isRunning()) return;

    // 播放攻击音效
    zhu.audio.playSound("assets/sound/big-thunder.ogg");
    for (&spellPositions, &spellAnimations) |*pos, *ani| {
        if (ani.isFinished()) {
            pos.* = position;
            ani.reset();
            mana -= 30;
            spellTimer.elapsed = 0;
            return;
        }
    }
}

fn updateButton() bool {
    const mousePos = zhu.window.mousePosition;

    var isTriggered = false;
    for (0..buttons.len) |i| {
        const index: f32 = @floatFromInt(i);
        const pos = buttonPosition.addX(index * 96);
        const buttonArea = zhu.Rect.init(pos, buttonSize);

        const hover = buttonArea.contains(mousePos);
        const press = zhu.window.isMouseDown(.LEFT);
        if (hover) {
            if (buttonIndex == null) {
                // 刚刚进入悬停状态，播放音效
                zhu.audio.playSound("assets/sound/UI_button12.ogg");
            }
            buttonIndex = i;
            buttonState = if (press) .pressed else .hover;
            if (zhu.window.isMouseRelease(.LEFT)) {
                triggerButton(i);
                isTriggered = true;
            }
            break;
        } else if (!press) {
            buttonState = .normal;
        }
    } else if (buttonState != .pressed) buttonIndex = null;
    return isTriggered;
}

fn triggerButton(index: usize) void {
    // 播放点击音效
    zhu.audio.playSound("assets/sound/UI_button08.ogg");
    switch (index) {
        0 => {
            world.isPause = !world.isPause; // 暂停游戏
            zhu.audio.isPaused = world.isPause;
        },
        1 => scene.changeScene(.world), // 重新开始游戏
        2 => scene.changeScene(.title), // 返回标题界面
        else => unreachable,
    }
}

pub fn draw() void {
    for (&spellPositions, &spellAnimations) |pos, ani| {
        if (ani.isFinished()) continue;

        const image = ani.currentImage();
        camera.drawImage(image, pos, .{
            .anchor = .center,
            .size = spellSize,
        });

        camera.drawOption(circle, pos, .{
            .anchor = .center,
            .size = spellSize,
            .color = .rgba(0, 255, 0, 100),
        });
    }
}

const imageId = zhu.graphics.imageId;

const Button = struct {
    normal: zhu.graphics.ImageId,
    hover: zhu.graphics.ImageId,
    pressed: zhu.graphics.ImageId,
};

const ButtonState = enum { normal, hover, pressed };

const buttonSize = zhu.Vector2.xy(96, 32);
const buttonPosition = zhu.Vector2.xy(990, 685);
const buttons: [3]Button = .{
    Button{
        .normal = zhu.graphics.imageId("UI/A_Pause1.png"),
        .hover = zhu.graphics.imageId("UI/A_Pause2.png"),
        .pressed = zhu.graphics.imageId("UI/A_Pause3.png"),
    },
    Button{
        .normal = zhu.graphics.imageId("UI/A_Restart1.png"),
        .hover = zhu.graphics.imageId("UI/A_Restart2.png"),
        .pressed = zhu.graphics.imageId("UI/A_Restart3.png"),
    },
    Button{
        .normal = zhu.graphics.imageId("UI/A_Back1.png"),
        .hover = zhu.graphics.imageId("UI/A_Back2.png"),
        .pressed = zhu.graphics.imageId("UI/A_Back3.png"),
    },
};
var buttonIndex: ?usize = null;
var buttonState: ButtonState = .normal;

fn drawButton() void {
    for (&buttons, 0..buttons.len) |button, i| {
        const index: f32 = @floatFromInt(i);
        const pos = buttonPosition.addX(index * 96);

        if (i == buttonIndex and buttonState != .normal) {
            if (buttonState == .pressed) {
                camera.drawOption(button.pressed, pos, .{
                    .size = buttonSize,
                });
            } else if (buttonState == .hover) {
                camera.drawOption(button.hover, pos, .{
                    .size = buttonSize,
                });
            }
        } else {
            camera.drawOption(button.normal, pos, .{
                .size = buttonSize,
            });
        }
    }
}

pub fn drawUI() void {
    drawButton();
    // 生命值
    var pos: zhu.Vector2 = .xy(30, 30);
    var option: camera.Option = .{ .anchor = .xy(0, 0.5) };

    const stats = player.stats;
    option.size = .xy(198, 21);
    camera.drawOption(imageId("UI/bar_bg.png"), pos.addX(30), option);
    var percent = zhu.math.percentInt(stats.health, stats.maxHealth);
    option.size.?.x = option.size.?.x * percent;
    camera.drawOption(imageId("UI/bar_red.png"), pos.addX(30), option);
    option.size = .xy(36, 39);
    camera.drawOption(imageId("UI/Red Potion.png"), pos, option);

    // 法力值
    pos = .xy(300, 30);
    option.size = .xy(198, 21);
    camera.drawOption(imageId("UI/bar_bg.png"), pos.addX(30), option);
    percent = zhu.math.percentInt(mana, 100);
    option.size.?.x = option.size.?.x * percent;
    camera.drawOption(imageId("UI/bar_blue.png"), pos.addX(30), option);
    option.size = .xy(36, 39);
    camera.drawOption(imageId("UI/Blue Potion.png"), pos, option);

    // 冷却时间
    const image = zhu.graphics.getImage("UI/Electric-Icon.png");
    var size = image.area.size.scale(0.14);
    pos = .xy(zhu.window.logicSize.x - 300, 30 - size.y / 2);
    camera.drawImage(image, pos, .{ .size = size });

    size.y = size.y * (1 - spellTimer.progress());
    camera.drawRect(.init(pos, size), .{ .color = .gray(0, 100) });

    // 得分
    pos = .xy(zhu.window.logicSize.x - 210, 6);
    camera.drawOption(imageId("UI/Textfield_01.png"), pos, .{
        .size = .xy(200, 48),
    });
    zhu.text.drawFmt("Score: {}", pos.addXY(10, 7), .{score});
}
```

## 效果

![暂停重启返回][1]

[1]: images/幽灵逃生26.gif

## 附录
