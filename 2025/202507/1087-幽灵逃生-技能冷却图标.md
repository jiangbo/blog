# 1087-幽灵逃生-技能冷却图标

## 目标

在 UI 界面上显示玩家的技能冷却图标。

## 环境

- Time 2026-01-12
- Zig 0.15.1

## 参考

1. <https://www.bilibili.com/video/BV1jf9XYQEhW>

## 想法

绘制两次，一次是绘制比较暗的颜色，一次是绘制正常，但是需要根据时间的百分比来绘制。

## battle.zig

将界面所有的绘制都移动这个模块来了。

```zig
const std = @import("std");
const zhu = @import("zhu");

const camera = zhu.camera;

const player = @import("player.zig");
const enemy = @import("enemy.zig");

pub const Stats = struct {
    health: u32 = 100, // 生命值
    maxHealth: u32 = 100, // 最大生命值
    attack: u32 = 40, // 攻击力
};

const circle = zhu.graphics.imageId("circle.png"); // 显示碰撞范围
const spellFrames = zhu.graphics.framesX(13, .xy(64, 64), 0.1);
const spellDamageIndex = 6; // 动画第 6 帧造成伤害，视觉效果好一点
const spellSize = spellFrames[0].area.size.scale(3);

var spellTimer: zhu.window.Timer = .init(2);
var spellAnimations: [4]zhu.graphics.FrameAnimation = undefined;
var spellPositions: [4]zhu.Vector2 = undefined;
var mana: u32 = 100;
var manaTimer: zhu.window.Timer = .init(1); // 每秒回复一次魔法值

pub fn init() void {
    const image = zhu.graphics.getImage("effect/Thunderstrike w blur.png");
    for (&spellAnimations) |*a| a.* = .initFinished(image, &spellFrames);
    spellTimer.stop(); // 一开始就可以直接使用魔法
}

pub fn update(delta: f32) void {
    spellTimer.update(delta);
    if (manaTimer.isFinishedLoopUpdate(delta)) {
        mana += 10;
        if (mana > 100) mana = 100;
    }

    // 角色使用魔法
    if (zhu.window.isMousePress(.LEFT)) {
        playerCastSpell(camera.toWorld(zhu.window.mousePosition));
    }

    for (&spellPositions, &spellAnimations) |pos, *ani| {
        if (ani.isFinished()) continue;

        const changed = ani.isNextOnceUpdate(delta);
        if (changed and ani.index == spellDamageIndex) {
            var iterator = std.mem.reverseIterator(enemy.enemies.items);
            while (iterator.nextPtr()) |e| {
                const len = (spellSize.x + enemy.size.x) * 0.5;
                const len2 = pos.sub(e.position).length2();
                if (len2 < len * len) e.stats.health -|= player.stats.attack;
                if (e.stats.health == 0) {
                    _ = enemy.enemies.swapRemove(iterator.index);
                }
            }
        }
    }
}

pub fn playerCastSpell(position: zhu.Vector2) void {
    if (mana < 30 or spellTimer.isRunning()) return;

    for (&spellPositions, &spellAnimations) |*pos, *ani| {
        if (ani.isFinished()) {
            pos.* = position;
            ani.reset();
            mana -= 30;
            spellTimer.elapsed = 0;
            return;
        }
    }
}

pub fn draw() void {
    for (&spellPositions, &spellAnimations) |pos, ani| {
        if (ani.isFinished()) continue;

        const image = ani.currentImage();
        camera.drawImage(image, pos, .{
            .anchor = .center,
            .size = spellSize,
        });

        camera.drawOption(circle, pos, .{
            .anchor = .center,
            .size = spellSize,
            .color = .{ .y = 1, .w = 0.4 },
        });
    }
}

const backImage = zhu.graphics.imageId("UI/bar_bg.png");
const healthBarImage = zhu.graphics.imageId("UI/bar_red.png");
const healthImage = zhu.graphics.imageId("UI/Red Potion.png");
const manaBarImage = zhu.graphics.imageId("UI/bar_blue.png");
const manaImage = zhu.graphics.imageId("UI/Blue Potion.png");
const electricImage = zhu.graphics.imageId("UI/Electric-Icon.png");
pub fn drawUI() void {

    // 生命值
    var pos: zhu.Vector2 = .xy(30, 30);
    var option: camera.Option = .{
        .scale = .xy(3, 3),
        .anchor = .xy(0, 0.5),
    };

    const stats = player.stats;
    camera.drawOption(backImage, pos.addX(30), option);
    var percent = zhu.math.percentInt(stats.health, stats.maxHealth);
    option.scale.x = option.scale.x * percent;
    camera.drawOption(healthBarImage, pos.addX(30), option);
    option.scale = .xy(0.5, 0.5);
    camera.drawOption(healthImage, pos, option);

    // 法力值
    pos = .xy(300, 30);
    option = .{ .scale = .xy(3, 3), .anchor = .xy(0, 0.5) };

    camera.drawOption(backImage, pos.addX(30), option);
    percent = zhu.math.percentInt(mana, 100);
    option.scale.x = option.scale.x * percent;
    camera.drawOption(manaBarImage, pos.addX(30), option);
    option.scale = .xy(0.5, 0.5);
    camera.drawOption(manaImage, pos, option);

    // 冷却时间
    var image = zhu.assets.getImage(electricImage);
    const size = image.area.size.scale(0.14);
    pos = .xy(zhu.window.logicSize.x - 300, 30 - size.y / 2);
    camera.drawImage(image, pos, .{
        .color = .init(0.3, 0.3, 0.3, 1),
        .size = size,
    });

    percent = spellTimer.progress();
    image.area.size.y = image.area.size.y * percent;
    camera.drawImage(image, pos, .{
        .size = .xy(size.x, size.y * percent),
    });
}
```

## 效果

![技能冷却图标][1]

[1]: images/幽灵逃生20.png

## 附录
