# 1082-幽灵逃生-批量生成敌人

## 目标

实现敌人的批量生成。

## 环境

- Time 2026-01-11
- Zig 0.15.1

## 参考

1. <https://www.bilibili.com/video/BV1jf9XYQEhW>

## 想法

优化了一下帧动画，支持判断是否刚刚结束。

## enemy.zig

一次生成一批敌人，这次相比之前，改动稍微要大一点。

```zig
const std = @import("std");
const zhu = @import("zhu");

const camera = zhu.camera;

const battle = @import("battle.zig");
const player = @import("player.zig");

const State = enum { normal, hurt, dead };
const Enemy = struct {
    position: zhu.Vector2,
    animation: zhu.graphics.FrameAnimation,
    stats: battle.Stats = .{},
    collided: bool = false,
};
const normalFrames = zhu.graphics.framesX(4, .xy(32, 32), 0.2);
const deadFrames = zhu.graphics.framesX(8, .xy(32, 32), 0.1);
const size = deadFrames[0].area.size.scale(2);
const maxSpeed = 100;
const circle = zhu.graphics.imageId("circle.png"); // 显示碰撞范围

var animations: zhu.graphics.EnumFrameAnimation(State) = undefined;
var enemies: std.ArrayList(Enemy) = .empty;
const spawnFrames = zhu.graphics.framesX(11, .xy(64, 64), 0.1);
var spawnAnimation: zhu.graphics.FrameAnimation = undefined;
var spawnTimer: zhu.window.Timer = .init(3); // 三秒生成一批敌人
var spawnEnemies: [20]Enemy = undefined; // 一次生成 20 个敌人

pub fn init() void {
    var image = zhu.graphics.getImage("sprite/ghost-Sheet.png");
    animations.set(.normal, .init(image, &normalFrames));
    image = zhu.graphics.getImage("sprite/ghostHurt-Sheet.png");
    animations.set(.hurt, .init(image, &normalFrames)); // 受伤和普通动画一样
    image = zhu.graphics.getImage("sprite/ghostDead-Sheet.png");
    animations.set(.dead, .init(image, &deadFrames));

    for (&animations.values, 0..) |*a, i| a.state = @intCast(i);

    const spawnImage = zhu.graphics.getImage("effect/184_3.png");
    spawnAnimation = .initFinished(spawnImage, &spawnFrames);
}

pub fn deinit() void {
    enemies.deinit(zhu.window.allocator);
}

pub fn update(delta: f32) void {
    if (spawnTimer.isFinishedAfterUpdate(delta)) {
        spawnTimer.elapsed = 0;
        spawnAnimation.reset();
        doSpawnEnemies();
    }

    spawnAnimation.onceUpdate(delta);
    if (spawnAnimation.isJustFinished()) {
        enemies.appendSlice(zhu.window.allocator, &spawnEnemies) catch unreachable;
    }

    for (enemies.items) |*enemy| {
        const dir = player.position.sub(enemy.position);
        const distance = dir.normalize().scale(maxSpeed * delta);
        enemy.position = enemy.position.add(distance);
        if (enemy.animation.isFinishedOnceUpdate(delta)) {
            const next = zhu.nextEnum(State, enemy.animation.state);
            enemy.animation = animations.get(next);
        }

        const len = (player.size.x + size.x) * 0.5;
        const len2 = player.position.sub(enemy.position).length2();
        enemy.collided = len2 < len * len;
        if (enemy.collided) player.hurt(enemy.stats.attack);
    }
}

fn doSpawnEnemies() void {
    for (&spawnEnemies) |*enemy| {
        const windowPos: zhu.Vector2 = .{
            .x = zhu.randomF32(0, zhu.window.logicSize.x),
            .y = zhu.randomF32(0, zhu.window.logicSize.y),
        };
        enemy.position = camera.toWorld(windowPos);
        enemy.stats = .{};
        enemy.animation = animations.get(.normal);
        const len = normalFrames.len;
        enemy.animation.index = zhu.randomInt(u8, 0, len);
    }
}

pub fn draw() void {
    if (spawnAnimation.isRunning()) {
        const image = spawnAnimation.currentImage();
        for (&spawnEnemies) |enemy| {
            camera.drawImage(image, enemy.position, .{
                .size = size,
                .anchor = .center,
            });
        }
    }

    for (enemies.items) |enemy| {
        const image = enemy.animation.currentImage();
        var option: camera.Option = .{ .size = size, .anchor = .center };
        camera.drawImage(image, enemy.position, option);

        option.color = .{ .y = 1, .w = 0.4 };
        if (enemy.collided) option.color = .{ .x = 1, .w = 0.4 };

        camera.drawOption(circle, enemy.position, option);
    }
}
```

## 效果

![批量生成敌人][1]

[1]: images/幽灵逃生15.gif

## 附录
