# 1158-怪物战争-攻击和动画

## 目标

实现敌人和角色可以攻击对方，并且攻击时播放对应的攻击动画。

## 环境

- Time 2026-02-04
- Zig 0.15.1

## 参考

1. <https://www.bilibili.com/video/BV1jf9XYQEhW>

## 想法

越来越复杂了，有些地方理不太清楚，一点一点做吧。

## scene.zig

修改动画的播放逻辑，支持了多动画。

```zig
const std = @import("std");
const zhu = @import("zhu");

const ecs = zhu.ecs;

const map = @import("map.zig");
const com = @import("component.zig");
const enemy = @import("enemy.zig");
const player = @import("player.zig");
const battle = @import("battle.zig");

var registry: ecs.Registry = undefined;
// var timer: zhu.Timer = .init(10);

pub fn init() void {
    registry = .init(zhu.assets.allocator);
    map.init();
    enemy.spawn(&registry);
}

pub fn deinit() void {
    map.deinit();
    registry.deinit();
}

pub fn update(delta: f32) void {
    // if (timer.isFinishedLoopUpdate(delta)) enemy.spawn(&registry);

    if (zhu.window.isMousePressed(.LEFT)) {
        player.spawn(&registry, .warrior);
    } else if (zhu.window.isMousePressed(.RIGHT)) {
        player.spawn(&registry, .archer);
    }

    // 更新动画事件，切换显示的图片
    updateAnimation(delta);
    // 地图更新，地图上的动画等。
    map.update(delta);

    enemy.move(&registry, delta);
    enemy.followPath(&registry);

    battle.cleanAttackTimerIfDone(&registry, delta);
    battle.cleanInvalidTarget(&registry);
    battle.attack(&registry);

    // 处理攻击事件
    for (registry.getEvents(com.AttackEvent)) |event| {
        // 目前先播放一个攻击动画
        const attacker = event.attacker;
        const ani = registry.getPtr(attacker, zhu.MultiAnimation);
        ani.change(@intFromEnum(com.StateEnum.attack));

        registry.add(attacker, com.AttackTimer{ .v = .init(2) });
    }

    // 处理到达终点的敌人
    for (registry.getEvents(ecs.Entity)) |entity| {
        registry.destroyEntity(entity);
    }
    registry.clearEvent(ecs.Entity);
    registry.clearEvent(com.AttackEvent);
}

fn updateAnimation(delta: f32) void {
    var view = registry.view(.{zhu.MultiAnimation});
    while (view.next()) |ent| {
        const animation = view.getPtr(ent, zhu.MultiAnimation);
        if (!animation.v.isNextOnceUpdate(delta)) continue; // 动画未跳到下一帧

        if (animation.v.isRunning()) { // 动画还在运行，并且切换到下一帧了。
            const sprite = view.getPtr(ent, com.Sprite);
            sprite.image = animation.v.subImage(sprite.image.size);
            continue;
        }

        // 动画播放结束，切换动画，需要根据角色和敌人来区分
        if (view.has(ent, com.Enemy)) {
            // 敌人需要区分是否被阻挡
            if (view.has(ent, com.BlockBy)) {
                animation.change(@intFromEnum(com.StateEnum.idle));
            } else {
                animation.change(@intFromEnum(com.StateEnum.walk));
            }
        } else {
            animation.change(@intFromEnum(com.StateEnum.idle));
        }
    }
}

pub fn draw() void {
    map.draw();

    // registry.sort(com.Sprite, struct {
    //     pub fn lessThan(a: com.Sprite, b: com.Sprite) bool {
    //         return a.image.texture.id < b.image.texture.id;
    //     }
    // }.lessThan);

    var view = registry.view(.{ com.Sprite, com.Position });
    while (view.next()) |entity| {
        const sprite = view.get(entity, com.Sprite);
        const position = view.get(entity, com.Position);
        const pos = position.add(sprite.offset);

        var flip = sprite.flip;
        const face = view.tryGet(entity, com.Face);
        if (face) |f| flip = (f == .Left) != flip;
        zhu.batch.drawImage(sprite.image, pos, .{ .flipX = !flip });
    }

    for (map.startPaths) |start| {
        if (start == 0) break;

        var previous = map.paths.get(start).?;
        while (previous.next != 0) {
            const next = map.paths.get(previous.next).?;
            zhu.batch.drawLine(previous.point, next.point, .{
                .color = .red,
                .width = 4,
            });
            previous = next;
        }
    }

    // std.log.info("command len: {}", .{zhu.batch.imageDrawCount()});
}
```

## battle.zig

攻击和计时器。

```zig
const std = @import("std");
const zhu = @import("zhu");

const ecs = zhu.ecs;
const com = @import("component.zig");

///
///  删除已经结束的攻击计时器。
///
pub fn cleanAttackTimerIfDone(reg: *ecs.Registry, delta: f32) void {
    var view = reg.viewOption(.{com.AttackTimer}, .{
        .reverse = true, // 倒序遍历，因为可能会移除组件
    });

    while (view.next()) |entity| {
        const timer = view.getPtr(entity, com.AttackTimer);
        if (timer.v.isFinishedOnceUpdate(delta)) {
            view.remove(entity, com.AttackTimer);
        }
    }
}

///
/// 验证攻击目标是否死亡，是否在攻击范围内。
///
pub fn cleanInvalidTarget(reg: *ecs.Registry) void {
    var view = reg.viewOption(.{ com.AttackRange, com.Target }, .{
        .reverse = true, // 倒序遍历，因为遍历 Target 的时候可能会移除它
    });

    while (view.next()) |entity| {
        const target = view.get(entity, com.Target).v;
        if (reg.validEntity(target)) { // 目标还存活
            const range = view.get(entity, com.AttackRange).v + 20; // 目标的中心
            const pos = view.get(entity, com.Position);
            const targetPos = reg.get(target, com.Position);
            if (pos.sub(targetPos).length2() <= range * range) {
                continue; // 目标在攻击范围内
            }
        }
        std.log.debug("entity: {} clean target: {}", .{ entity, target });
        view.remove(entity, com.Target);
    }
}

///
/// 攻击
///
pub fn attack(reg: *ecs.Registry) void {
    var view = reg.view(.{ com.Position, com.AttackRange });
    while (view.next()) |entity| {
        if (view.has(entity, com.AttackTimer)) continue; // 攻击冷却中

        if (view.tryGet(entity, com.Target)) |target| {
            reg.addEvent(com.AttackEvent{ // 已经有目标了，直接攻击
                .attacker = view.toEntity(entity),
                .target = target.v,
            });
            continue;
        }

        const pos = view.get(entity, com.Position);
        const range = view.get(entity, com.AttackRange).v + 20; // 目标的中心
        const range2 = range * range;

        var closestTarget: ?zhu.ecs.Entity.Index = null; // 找最近的敌方
        var closestLength2: f32 = std.math.floatMax(f32);

        const isEnemy = view.has(entity, com.Enemy);
        var targetView = reg.view(.{com.Position});
        while (targetView.next()) |target| {
            if (isEnemy == view.has(target, com.Enemy)) continue; // 同一边的

            const targetPos = targetView.get(target, com.Position);
            const length2 = pos.sub(targetPos).length2();
            if (length2 <= range2 and length2 < closestLength2) {
                closestTarget = target;
                closestLength2 = length2;
            }
        }

        if (closestTarget) |target| {
            view.add(entity, com.Target{ .v = view.toEntity(target) });
            std.log.debug("entity: {} attack: {}", .{ entity, target });
            reg.addEvent(com.AttackEvent{ // 找到了目标，攻击
                .attacker = view.toEntity(entity),
                .target = view.toEntity(target),
            });
        }
    }
}
```

## 效果

![攻击和动画][1]

[1]: images/怪物战争16.png

## 附录
