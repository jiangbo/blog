# 1151-怪物战争-解析移动路径

## 目标

解析地图中保存的移动路径，然后渲染出具体的路径。

## 环境

- Time 2026-02-02
- Zig 0.15.1

## 参考

1. <https://www.bilibili.com/video/BV1jf9XYQEhW>

## 想法

解析了 path 层中的路径，然后使用直线段进行渲染。

## scene.zig

将地图的东西，放到了 map.zig 模块中，新增一个 scene.zig 来管理场景。

```zig
const std = @import("std");
const zhu = @import("zhu");

const map = @import("map.zig");

pub fn init() void {
    map.init();
}

pub fn deinit() void {
    map.deinit();
}

pub fn update(delta: f32) void {
    map.update(delta);
}

pub fn draw() void {
    map.draw();
    for (map.startPaths) |start| {
        if (start == 0) break;

        var prev = map.paths.get(start).?;
        while (prev.next != 0) {
            const next = map.paths.get(prev.next).?;
            zhu.batch.drawLine(prev.point, next.point, .{
                .color = .red,
                .width = 4,
            });
            prev = next;
        }
    }
}
```

## map.zig

```zig
const std = @import("std");
const zhu = @import("zhu");

const batch = zhu.batch;
const tiled = zhu.extend.tiled;

const level: tiled.Map = @import("zon/level1.zon");
const data = level;
const Animation = struct {
    position: zhu.Vector2,
    value: zhu.graphics.Animation,
    extend: tiled.ObjectExtend = .{},
};
var animations: std.ArrayList(Animation) = .empty;
var tileVertexes: std.ArrayList(batch.Vertex) = .empty;

const Path = struct {
    point: zhu.Vector2, // 路径点位置
    next: u8 = 0, // 终点没有下一个路径点
    next2: u8 = 0, // 可选的第二条分支路径

    pub fn randomNext(self: Path) u8 {
        if (self.next2 == 0) return self.next;
        return if (zhu.randomBool()) self.next else self.next2;
    }
};
pub var paths: std.AutoHashMapUnmanaged(u8, Path) = .empty;
pub var startPaths: [10]u8 = undefined; // 最多 10 条起始路径

pub fn init() void {
    tiled.backgroundColor = data.backgroundColor;
    @memset(&startPaths, 0);

    for (data.layers) |*layer| {
        if (std.mem.eql(u8, "path", layer.name)) {
            parsePathLayer(layer);
        } else {
            switch (layer.type) {
                .tile => parseTileLayer(layer),
                .object => parseObjectLayer(layer),
                else => unreachable,
            }
        }
    }

    std.mem.sortUnstable(Animation, animations.items, {}, struct {
        fn lessThan(_: void, a: Animation, b: Animation) bool {
            return a.position.y < b.position.y;
        }
    }.lessThan);
}

pub fn deinit() void {
    tileVertexes.deinit(zhu.assets.allocator);
    animations.deinit(zhu.assets.allocator);
    paths.deinit(zhu.assets.allocator);
}

fn parsePathLayer(layer: *const tiled.Layer) void {
    for (layer.objects) |object| {
        var path: Path = .{ .point = object.position };
        for (object.properties) |prop| {
            if (prop.is("next")) {
                path.next = @intCast(prop.value.object);
            } else if (prop.is("next2")) {
                path.next2 = @intCast(prop.value.object);
            } else if (prop.is("start")) {
                for (&startPaths) |*startPath| {
                    if (startPath.* != 0) continue;
                    startPath.* = @intCast(object.gid);
                    break;
                } else unreachable;
            }
        }
        paths.put(zhu.assets.allocator, @intCast(object.gid), path) //
        catch @panic("oom, can't put path");
    }
}

fn parseTileLayer(layer: *const tiled.Layer) void {
    const ts = tiled.getTileSetById(zhu.id("Tilemap.tsj"));
    const tileImage = zhu.assets.getImage(ts.image);

    for (layer.data, 0..) |gid, index| {
        if (gid == 0) continue;

        const x: f32 = @floatFromInt(index % data.width);
        const y: f32 = @floatFromInt(index / data.width);
        var pos = data.tileSize.mul(.xy(x, y));

        var image: zhu.graphics.Image = undefined;
        const tileSetRef = data.getTileSetRefByGid(gid);
        const tileSet = tiled.getTileSetByRef(tileSetRef);
        const localId = gid - tileSetRef.firstGid;

        const tile = tileSet.getTileByLocalId(localId);
        if (tile != null and tile.?.animation.len > 0) {
            image = zhu.assets.getImage(tileSet.image);
            animations.append(zhu.assets.allocator, .{
                .position = pos,
                .value = .init(image, tile.?.animation),
            }) catch @panic("oom, can't append animation");
            continue;
        }

        if (tileSet.columns == 0) { // 单图片瓦片集的列数
            image = zhu.assets.getImage(tile.?.id);
            pos.y = pos.y - image.area.size.y + data.tileSize.y;
        } else {
            const area = data.tileArea(localId, tileSet.columns);
            image = tileImage.sub(area);
        }

        tileVertexes.append(zhu.assets.allocator, .{
            .position = pos,
            .size = image.area.size,
            .texturePosition = image.toTexturePosition(),
        }) catch @panic("oom, can't append tile");

        // if (tile) |t| parseProperties(index, t); // 解析碰撞信息
    }
}

fn parseObjectLayer(layer: *const tiled.Layer) void {
    for (layer.objects) |object| {
        if (object.gid == 0) {
            std.log.info("gid 0, position: {}", .{object.position});
            continue;
        }

        const tileSetRef = data.getTileSetRefByGid(object.gid);
        const tileSet = tiled.getTileSetByRef(tileSetRef);
        const localId = object.gid - tileSetRef.firstGid;

        const tile = tileSet.getTileByLocalId(localId);

        if (tile == null) {
            std.log.info("tile is null, gid: {}", .{object.gid});
            continue;
        }

        const pos = object.position.addY(-object.size.y);
        if (tileSet.columns == 0) {
            const image = zhu.assets.getImage(tile.?.id);
            tileVertexes.append(zhu.assets.allocator, .{
                .position = pos,
                .size = object.size,
                .texturePosition = image.toTexturePosition(),
            }) catch @panic("oom, can't append tile");
        } else {
            const image = zhu.assets.getImage(tileSet.image);
            animations.append(zhu.assets.allocator, .{
                .position = pos,
                .value = .init(image, tile.?.animation),
                .extend = object.extend,
            }) catch @panic("oom, can't append animation");
        }
    }
}

pub fn update(delta: f32) void {
    for (animations.items) |*item| item.value.loopUpdate(delta);
}

pub fn draw() void {
    batch.currentCommand().texture = batch.whiteImage.texture;
    batch.vertexBuffer.appendSliceAssumeCapacity(tileVertexes.items);

    for (animations.items) |item| {
        batch.drawImage(item.value.currentImage(), item.position, .{
            .flipX = item.extend.flipX,
        });
    }
}
```

## 效果

![解析移动路径][1]

[1]: images/怪物战争09.png

## 附录
