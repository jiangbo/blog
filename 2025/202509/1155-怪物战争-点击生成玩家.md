# 1155-怪物战争-点击生成玩家

## 目标

定义了玩家的数据模板，然后在鼠标的点击位置生成玩家。

## 环境

- Time 2026-02-03
- Zig 0.15.1

## 参考

1. <https://www.bilibili.com/video/BV1jf9XYQEhW>

## 想法

仿照敌人生成的方式，定义玩家的数据模板，然后生成玩家。这个合批和排序的问题要想想怎么解决。

## scene.zig

目前不排序的情况下，已经快到每帧 16 批次了。

```zig
const std = @import("std");
const zhu = @import("zhu");

const ecs = zhu.ecs;

const map = @import("map.zig");
const com = @import("component.zig");
const enemy = @import("enemy.zig");
const player = @import("player.zig");

var registry: ecs.Registry = undefined;
// var timer: zhu.Timer = .init(10);

pub fn init() void {
    registry = .init(zhu.assets.allocator);
    map.init();
    enemy.spawn(&registry);

    player.spawn(&registry, .warrior);
}

pub fn deinit() void {
    map.deinit();
    registry.deinit();
}

pub fn update(delta: f32) void {
    // if (timer.isFinishedLoopUpdate(delta)) enemy.spawn(&registry);

    if (zhu.window.isMousePressed(.LEFT)) {
        player.spawn(&registry, .warrior);
    } else if (zhu.window.isMousePressed(.RIGHT)) {
        player.spawn(&registry, .archer);
    }

    map.update(delta);

    enemy.followPath(&registry);

    var view = registry.view(.{ com.Position, com.Velocity });
    while (view.next()) |entity| {
        const position = view.getPtr(entity, com.Position);
        const velocity = view.get(entity, com.Velocity);
        position.* = position.*.add(velocity.v.scale(delta));
    }

    // 处理到达终点的敌人
    for (registry.getEvents(ecs.Entity)) |entity| {
        registry.destroyEntity(entity);
    }
    registry.clearEvent(ecs.Entity);
}

pub fn draw() void {
    map.draw();

    // registry.sort(com.Sprite, struct {
    //     pub fn lessThan(a: com.Sprite, b: com.Sprite) bool {
    //         return a.image.texture.id < b.image.texture.id;
    //     }
    // }.lessThan);

    var view = registry.view(.{ com.Sprite, com.Position });
    while (view.next()) |entity| {
        const sprite = view.get(entity, com.Sprite);
        const position = view.get(entity, com.Position);
        const pos = position.add(sprite.offset);

        const velocity = view.tryGet(entity, com.Velocity);
        var flip = sprite.flip;
        if (velocity) |vel| flip = (vel.v.x < 0) != flip;
        zhu.batch.drawImage(sprite.image, pos, .{ .flipX = !flip });
    }

    for (map.startPaths) |start| {
        if (start == 0) break;

        var previous = map.paths.get(start).?;
        while (previous.next != 0) {
            const next = map.paths.get(previous.next).?;
            zhu.batch.drawLine(previous.point, next.point, .{
                .color = .red,
                .width = 4,
            });
            previous = next;
        }
    }

    std.log.info("command len: {}", .{zhu.batch.imageDrawCount()});
}
```

## player.zig

新增了一个玩家的模块。

```zig
const std = @import("std");
const zhu = @import("zhu");

const ecs = zhu.ecs;

const com = @import("component.zig");

pub const Enum = enum { warrior, archer, lancer, witch };
const Player = struct {
    playerEnum: Enum,
    name: []const u8,
    description: []const u8,
    health: u32,
    attack: u32,
    defense: u32,
    range: f32,
    interval: f32,
    block: u8,
    cost: u8,
    image: struct { path: [:0]const u8, size: zhu.Vector2 },
    faceRight: bool,
    size: zhu.Vector2,
    offset: zhu.Vector2,
};

const zon: std.EnumArray(Enum, Player) = @import("zon/player.zon");

pub fn spawn(registry: *ecs.Registry, playerEnum: Enum) void {
    const value = zon.get(playerEnum);
    const playerEntity = registry.createEntity();
    registry.add(playerEntity, zhu.window.mousePosition);

    const path = value.image.path;
    const image = zhu.assets.loadImage(path, value.image.size);
    registry.add(playerEntity, com.Sprite{
        .image = image.sub(.init(.zero, value.size)),
        .offset = value.offset,
        .flip = value.faceRight,
    });
}
```

## 效果

![点击生成玩家][1]

[1]: images/怪物战争13.png

## 附录
