# 1141-阳光岛-结束按钮功能

## 目标

实现结束场景，并且实现按钮功能。

## 环境

- Time 2026-01-31
- Zig 0.15.1

## 参考

1. <https://www.bilibili.com/video/BV1jf9XYQEhW>

## 想法

直接在场景中绘制，教程中对这些都是封装了对象的，我要不要封装？

## scene.zig

结束场景。

```zig
const std = @import("std");
const zhu = @import("zhu");

const window = zhu.window;
const batch = zhu.batch;

const title = @import("title.zig");
const map = @import("map.zig");
const menu = @import("menu.zig");
const player = @import("player.zig");
const object = @import("object.zig");

const Session = extern struct {
    level: u8 = 0,
    health: u8 = 3,
    score: u32 = 0,
    highScore: u32 = 0,
};

const StateEnum = enum { title, play, pause, over };

const savePath = "save/save.dat";
var session: Session = .{};
var state: StateEnum = .title;
var win: bool = false;

pub fn init() void {
    batch.camera.position = .zero;
    if (state == .title) return title.init();

    menu.menuIndex = 1;
    map.init(session.level);

    for (map.objects.items, 0..) |obj, index| {
        if (obj.type != .player) continue;
        player.init(obj.position, obj.size);
        player.health = session.health;
        player.score = session.score;
        _ = map.objects.swapRemove(index);
        break;
    }
    object.init(map.objects);

    zhu.audio.playMusic("assets/audio/hurry_up_and_run.ogg");
}

pub fn start() void {
    state = .play;
    session = .{};
    init();
}

pub fn load() void {
    state = .play;
    session = loadSession();
    init();
}

fn loadSession() Session {
    var buffer: [64]u8 = undefined;
    const content = zhu.window.readBuffer(savePath, &buffer) catch {
        return .{};
    };

    var reader = std.Io.Reader.fixed(content);
    return reader.takeStruct(Session, .little) catch unreachable;
}

fn saveSession() !void {
    session.health = player.health;
    session.score = player.score;
    session.highScore = @max(player.score, session.highScore);

    var buffer: [64]u8 = undefined;
    var writer = std.Io.Writer.fixed(&buffer);
    try writer.writeStruct(session, .little);

    try zhu.window.saveAll(savePath, buffer[0..writer.end]);
}

pub fn changeNextLevel() void {
    session.level += 1;
    saveSession() catch unreachable;
    init();
}

fn backToTitle() void {
    state = .title;
    std.log.info("back to title", .{});
    init();
}

pub fn deinit() void {
    map.deinit();
}

pub fn update(delta: f32) void {
    if (window.isKeyDown(.LEFT_ALT) and window.isKeyReleased(.ENTER)) {
        return window.toggleFullScreen();
    }

    switch (state) {
        .title => title.update(delta),
        .play => {
            // 玩家死亡
            if (player.position.y > map.map.size().y + 10) {
                state = .over;
                menu.menuIndex = 2;
            }
            player.update(delta);
            object.update(delta);
            if (zhu.window.isKeyReleased(.ESCAPE)) state = .pause;
        },
        .pause => if (menu.update()) |event| {
            switch (event) {
                0 => state = .play, // 继续游戏
                1 => saveSession() catch unreachable, // 保存存档
                2 => backToTitle(), // 返回标题
                3 => zhu.window.exit(), // 退出游戏
                else => unreachable,
            }
        },
        .over => if (menu.update()) |event| {
            switch (event) {
                0 => backToTitle(), // 返回标题
                1 => start(), // 重新开始
                else => unreachable,
            }
        },
    }
}

pub fn draw() void {
    zhu.batch.beginDraw(.black);
    defer zhu.batch.endDraw();

    if (state == .title) return title.draw();

    map.draw();
    object.draw();
    player.draw();

    batch.camera.modeEnum = .window;
    defer batch.camera.modeEnum = .world;

    if (state == .pause) {
        const size = zhu.window.size;
        const pos: zhu.Vector2 = .xy(size.x * 0.5, size.y * 0.2);
        zhu.text.drawTextCenter("PAUSE", pos, .{ .size = 32 });
        menu.draw();
    } else if (state == .over) drawOver();
}

fn drawOver() void {
    const str = if (win) "YOU WIN! CONGRATS!" else "YOU DIED! TRY AGAIN!";
    const color: zhu.Color = if (win) .green else .red;

    const size = zhu.window.size;
    var pos: zhu.Vector2 = .xy(size.x * 0.5, size.y * 0.3);
    zhu.text.drawTextCenter(str, pos, .{
        .size = 48,
        .color = color,
    });

    var buffer: [128]u8 = undefined;
    var text = zhu.text.format(&buffer, "Score: {}", .{player.score});
    pos = .xy(size.x * 0.5, size.y * 0.5);
    zhu.text.drawTextCenter(text, pos, .{ .size = 32 });

    text = zhu.text.format(&buffer, "High Score: {}", .{session.highScore});
    pos = .xy(size.x * 0.5, size.y * 0.6);
    zhu.text.drawTextCenter(text, pos, .{ .size = 32 });

    menu.draw();
}

fn drawHelpInfo() void {
    const text =
        \\按键说明：
        \\上：W，下：S，左：A，右：D
        \\确定：F，取消：Q，菜单：E
        \\帮助：H  按一次打开，再按一次关闭
    ;
    zhu.text.drawColor(text, .xy(10, 10), .green);
}
```

## 效果

![结束按钮功能][1]

[1]: images/阳光岛38.png

## 附录
