# 0793-植物明星大乱斗-渲染背景图片

## 目标

加载并且渲染菜单场景的背景图片。

## 环境

- Time 2025-03-08
- Zig 0.14.0-dev.3298+6fe1993d8

## 参考

1. <https://www.bilibili.com/video/BV1jx4y1t7eP>

## 想法

虽然看起来很多，其实很多都是上一个项目拷贝过来的，直接拿过来使用就行。

## window.zig

无变化。

## cache.zig

```zig
const std = @import("std");
const gfx = @import("graphics.zig");

var allocator: std.mem.Allocator = undefined;

pub fn init(alloc: std.mem.Allocator) void {
    allocator = alloc;
    TextureCache.init();
}

pub fn deinit() void {
    TextureCache.deinit();
}

pub const TextureCache = struct {
    const stbi = @import("stbi");
    const Cache = std.StringHashMap(gfx.Texture);

    var cache: Cache = undefined;

    pub fn init() void {
        cache = Cache.init(allocator);
        stbi.init(allocator);
    }

    pub fn load(path: [:0]const u8) ?gfx.Texture {
        const entry = cache.getOrPut(path) catch |e| {
            std.log.err("texture cache allocate error: {}", .{e});
            return null;
        };
        if (entry.found_existing) return entry.value_ptr.*;

        std.log.info("loading texture from: {s}", .{path});
        var image = stbi.Image.loadFromFile(path, 4) catch |e| {
            std.log.err("loading image error: {}", .{e});
            return null;
        };

        defer image.deinit();

        const texture = gfx.Texture.init(image.width, image.height, image.data);
        entry.value_ptr.* = texture;
        entry.key_ptr.* = allocator.dupe(u8, path) catch unreachable;
        return texture;
    }

    pub fn deinit() void {
        stbi.deinit();
        var keyIter = cache.keyIterator();
        while (keyIter.next()) |key| allocator.free(key.*);
        cache.deinit();
    }
};
```

## graphics.zig

```zig
const std = @import("std");
const sk = @import("sokol");

const render = @import("shader/single.glsl.zig");

pub const Camera = struct {
    const zm = @import("zmath");

    proj: zm.Mat,

    pub fn init(width: f32, height: f32) Camera {
        const proj = zm.orthographicOffCenterLh(0, width, 0, height, 0, 1);
        return .{ .proj = proj };
    }

    pub fn vp(self: Camera) zm.Mat {
        return self.proj;
    }
};

pub var camera: Camera = undefined;

pub const CommandEncoder = struct {
    pub fn beginRenderPass(color: Color) RenderPassEncoder {
        return RenderPassEncoder.begin(color);
    }
};

pub const RenderPassEncoder = struct {
    pub fn begin(color: Color) RenderPassEncoder {
        var action = sk.gfx.PassAction{};
        action.colors[0] = .{ .load_action = .CLEAR, .clear_value = color };
        sk.gfx.beginPass(.{ .action = action, .swapchain = sk.glue.swapchain() });
        return RenderPassEncoder{};
    }

    pub fn setPipeline(self: *RenderPassEncoder, pipeline: RenderPipeline) void {
        _ = self;
        sk.gfx.applyPipeline(pipeline.value);
    }

    pub fn setBindGroup(self: *RenderPassEncoder, group: BindGroup) void {
        _ = self;
        sk.gfx.applyUniforms(render.UB_vs_params, sk.gfx.asRange(&group.uniform));
        sk.gfx.applyBindings(group.value);
    }

    pub fn draw(self: *RenderPassEncoder, number: u32) void {
        _ = self;
        sk.gfx.draw(0, number, 1);
    }

    pub fn submit(self: *RenderPassEncoder) void {
        _ = self;
        sk.gfx.endPass();
        sk.gfx.commit();
    }
};

const cache = @import("cache.zig");

pub const Texture = struct {
    x: f32 = 0,
    y: f32 = 0,
    width: f32,
    height: f32,
    value: sk.gfx.Image,

    pub fn load(path: [:0]const u8) ?Texture {
        return cache.TextureCache.load(path);
    }

    pub fn init(width: u32, height: u32, data: []u8) Texture {
        const image = sk.gfx.allocImage();

        sk.gfx.initImage(image, .{
            .width = @as(i32, @intCast(width)),
            .height = @as(i32, @intCast(height)),
            .pixel_format = .RGBA8,
            .data = init: {
                var imageData = sk.gfx.ImageData{};
                imageData.subimage[0][0] = sk.gfx.asRange(data);
                break :init imageData;
            },
        });

        return .{
            .width = @floatFromInt(width),
            .height = @floatFromInt(height),
            .value = image,
        };
    }
};

pub const Sampler = struct {
    value: sk.gfx.Sampler,

    pub fn liner() Sampler {
        const sampler = sk.gfx.makeSampler(.{
            .min_filter = .LINEAR,
            .mag_filter = .LINEAR,
        });
        return .{ .value = sampler };
    }

    pub fn nearest() Sampler {
        const sampler = sk.gfx.makeSampler(.{
            .min_filter = .NEAREST,
            .mag_filter = .NEAREST,
        });
        return .{ .value = sampler };
    }
};

pub const Color = sk.gfx.Color;
pub const Buffer = sk.gfx.Buffer;

pub const BindGroup = struct {
    value: sk.gfx.Bindings = .{},
    uniform: render.VsParams = undefined,

    pub fn bindIndexBuffer(self: *BindGroup, buffer: Buffer) void {
        self.value.index_buffer = buffer;
    }

    pub fn bindVertexBuffer(self: *BindGroup, index: u32, buffer: Buffer) void {
        self.value.vertex_buffers[index] = buffer;
    }

    pub fn bindTexture(self: *BindGroup, index: u32, texture: Texture) void {
        self.value.images[index] = texture.value;
    }

    pub fn bindSampler(self: *BindGroup, index: u32, sampler: Sampler) void {
        self.value.samplers[index] = sampler.value;
    }

    pub fn bindUniformBuffer(self: *BindGroup, uniform: UniformParams) void {
        self.uniform = uniform;
    }
};

const UniformParams = render.VsParams;
pub var renderer: Renderer = undefined;

pub const Renderer = struct {
    bind: BindGroup,
    renderPass: RenderPassEncoder,

    var indexBuffer: ?Buffer = null;
    var pipeline: ?RenderPipeline = null;
    var sampler: ?Sampler = null;

    pub fn init() Renderer {
        var self = Renderer{ .bind = .{}, .renderPass = undefined };

        indexBuffer = indexBuffer orelse sk.gfx.makeBuffer(.{
            .type = .INDEXBUFFER,
            .data = sk.gfx.asRange(&[_]u16{ 0, 1, 2, 0, 2, 3 }),
        });
        self.bind.bindIndexBuffer(indexBuffer.?);

        sampler = sampler orelse Sampler.liner();
        self.bind.bindSampler(render.SMP_smp, sampler.?);

        pipeline = pipeline orelse RenderPipeline{
            .value = sk.gfx.makePipeline(.{
                .shader = sk.gfx.makeShader(render.singleShaderDesc(sk.gfx.queryBackend())),
                .layout = init: {
                    var l = sk.gfx.VertexLayoutState{};
                    l.attrs[render.ATTR_single_position].format = .FLOAT3;
                    l.attrs[render.ATTR_single_color0].format = .FLOAT3;
                    l.attrs[render.ATTR_single_texcoord0].format = .FLOAT2;
                    break :init l;
                },
                .colors = init: {
                    var c: [4]sk.gfx.ColorTargetState = @splat(.{});
                    c[0] = .{
                        .blend = .{
                            .enabled = true,
                            .src_factor_rgb = .SRC_ALPHA,
                            .dst_factor_rgb = .ONE_MINUS_SRC_ALPHA,
                        },
                    };
                    break :init c;
                },
                .index_type = .UINT16,
                .depth = .{ .compare = .LESS_EQUAL, .write_enabled = true },
            }),
        };

        return self;
    }

    pub fn draw(self: *Renderer, x: f32, y: f32, tex: Texture) void {
        const vertexBuffer = sk.gfx.makeBuffer(.{
            .data = sk.gfx.asRange(&[_]f32{
                // 顶点和颜色
                x,             y + tex.height, 0.5, 1.0, 1.0, 1.0, 0, 1,
                x + tex.width, y + tex.height, 0.5, 1.0, 1.0, 1.0, 1, 1,
                x + tex.width, y,              0.5, 1.0, 1.0, 1.0, 1, 0,
                x,             y,              0.5, 1.0, 1.0, 1.0, 0, 0,
            }),
        });

        const params = UniformParams{ .vp = camera.vp() };
        self.bind.bindUniformBuffer(params);
        self.bind.bindVertexBuffer(0, vertexBuffer);

        self.renderPass.setPipeline(pipeline.?);
        self.bind.bindTexture(render.IMG_tex, tex);
        self.renderPass.setBindGroup(self.bind);
        sk.gfx.draw(0, 6, 1);
        sk.gfx.destroyBuffer(vertexBuffer);
    }
};

pub const RenderPipeline = struct {
    value: sk.gfx.Pipeline,
};
```

## scene.zig

```zig
const std = @import("std");
const window = @import("window.zig");
const gfx = @import("graphics.zig");

pub var currentScene: Scene = undefined;

var menuScene: MenuScene = undefined;
var gameScene: GameScene = undefined;
var selectorScene: SelectorScene = undefined;

pub const SceneType = enum { menu, game, selector };
pub const Scene = union(SceneType) {
    menu: *MenuScene,
    game: *GameScene,
    selector: *SelectorScene,

    pub fn enter(self: Scene) void {
        switch (self) {
            inline else => |s| s.enter(),
        }
    }

    pub fn exit(self: Scene) void {
        switch (self) {
            inline else => |s| s.exit(),
        }
    }

    pub fn event(self: Scene, ev: *const window.Event) void {
        switch (self) {
            inline else => |s| s.event(ev),
        }
    }

    pub fn update(self: Scene) void {
        switch (self) {
            inline else => |s| s.update(),
        }
    }

    pub fn render(self: Scene) void {
        switch (self) {
            inline else => |s| s.render(),
        }
    }
};

pub fn init() void {
    std.log.info("scene init", .{});

    menuScene = MenuScene.init();
    gameScene = GameScene{};
    selectorScene = SelectorScene{};
    currentScene = Scene{ .menu = &menuScene };

    currentScene.enter();
}

fn changeCurrentScene(sceneType: SceneType) void {
    currentScene.exit();
    currentScene = switch (sceneType) {
        .menu => Scene{ .menu = &menuScene },
        .game => Scene{ .game = &gameScene },
        .selector => Scene{ .selector = &selectorScene },
    };
    currentScene.enter();
}

pub fn deinit() void {
    std.log.info("scene deinit", .{});
}

pub const MenuScene = struct {
    background: gfx.Texture,

    pub fn init() MenuScene {
        std.log.info("menu scene init", .{});

        return .{
            .background = gfx.Texture.load("assets/menu_background.png").?,
        };
    }

    pub fn enter(self: *MenuScene) void {
        std.log.info("menu scene enter", .{});
        _ = self;
    }

    pub fn exit(self: *MenuScene) void {
        std.log.info("menu scene exit", .{});
        _ = self;
    }

    pub fn event(self: *MenuScene, ev: *const window.Event) void {
        std.log.info("menu scene event", .{});

        if (ev.type == .KEY_UP) changeCurrentScene(.game);

        _ = self;
    }

    pub fn update(self: *MenuScene) void {
        std.log.info("menu scene update", .{});
        _ = self;
    }

    pub fn render(self: *MenuScene) void {
        gfx.renderer.draw(0, 0, self.background);
        window.displayText(2, 2, "menu scene");
    }
};

pub const GameScene = struct {
    pub fn enter(self: *GameScene) void {
        std.log.info("game scene enter", .{});
        _ = self;
    }

    pub fn exit(self: *GameScene) void {
        std.log.info("game scene exit", .{});
        _ = self;
    }

    pub fn event(self: *GameScene, ev: *const window.Event) void {
        std.log.info("game scene event", .{});
        _ = self;
        if (ev.type == .KEY_UP) changeCurrentScene(.menu);
    }

    pub fn update(self: *GameScene) void {
        std.log.info("game scene update", .{});
        _ = self;
    }

    pub fn render(self: *GameScene) void {
        _ = self;

        window.displayText(2, 2, "game scene");
    }
};

pub const SelectorScene = struct {
    pub fn enter(self: *SelectorScene) void {
        std.log.info("selector scene enter", .{});
        _ = self;
    }

    pub fn exit(self: *SelectorScene) void {
        std.log.info("selector scene exit", .{});
        _ = self;
    }

    pub fn event(self: *SelectorScene, ev: *const window.Event) void {
        std.log.info("selector scene event", .{});
        _ = self;
        _ = ev;
    }

    pub fn update(self: *SelectorScene) void {
        std.log.info("selector scene update", .{});
        _ = self;
    }

    pub fn render(self: *SelectorScene) void {
        std.log.info("selector scene render", .{});
        _ = self;
    }
};
```

## main.zig

```zig
const std = @import("std");

const gfx = @import("graphics.zig");
const window = @import("window.zig");
const scene = @import("scene.zig");
const cache = @import("cache.zig");

pub fn init() void {
    cache.init(allocator);
    gfx.camera = gfx.Camera.init(window.width, window.height);
    gfx.renderer = gfx.Renderer.init();
    scene.init();
}

pub fn event(ev: *const window.Event) void {
    scene.currentScene.event(ev);
}

pub fn update() void {
    scene.currentScene.update();
}

pub fn render() void {
    var passEncoder = gfx.CommandEncoder.beginRenderPass(.{ .r = 1, .b = 1, .a = 1.0 });
    defer passEncoder.submit();

    gfx.renderer.renderPass = passEncoder;
    scene.currentScene.render();
}

pub fn deinit() void {
    scene.deinit();
    cache.deinit();
}

var allocator: std.mem.Allocator = undefined;

pub fn main() void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();

    allocator = gpa.allocator();
    window.width = 1280;
    window.height = 720;

    window.run(.{
        .title = "植物明星大乱斗",
        .init = init,
        .event = event,
        .update = update,
        .render = render,
        .deinit = deinit,
    });
}
```

## 效果

![菜单背景图片][1]

[1]: images/植物明星大乱斗05.webp

## 附录
